"""
CVE Data Fetchers.

Implements fetching CVE data from various sources:
- NVD (National Vulnerability Database)
- Ubuntu Security API
- Debian Security Tracker
- Red Hat Security Data API
- Microsoft Security Response Center
- FreeBSD VuXML
"""

import asyncio
import logging
import defusedxml.ElementTree as ET  # nosec B405 - using defusedxml for safe XML parsing
from datetime import datetime, timedelta, timezone
from typing import Any, Dict, List, Optional, Tuple

import httpx
from sqlalchemy.orm import Session, sessionmaker

from backend.persistence import db as db_module
from backend.persistence.models import (
    PackageVulnerability,
    Vulnerability,
)

from .cve_sources import CVE_SOURCES, CveRefreshError

logger = logging.getLogger(__name__)

# Constants
UTC_TIMEZONE_OFFSET = "+00:00"


class SeverityConverter:
    """Helper methods for converting severity scores/priorities."""

    @staticmethod
    def cvss2_to_severity(score: float) -> str:
        """Convert CVSS v2 score to severity string."""
        if score >= 7.0:
            return "HIGH"
        if score >= 4.0:
            return "MEDIUM"
        if score > 0:
            return "LOW"
        return "NONE"

    @staticmethod
    def cvss3_to_severity(score: float) -> str:
        """Convert CVSS v3.x score to severity string."""
        if score >= 9.0:
            return "CRITICAL"
        if score >= 7.0:
            return "HIGH"
        if score >= 4.0:
            return "MEDIUM"
        if score > 0:
            return "LOW"
        return "NONE"

    @staticmethod
    def ubuntu_priority_to_severity(priority: str) -> str:
        """Convert Ubuntu priority to severity string."""
        priority_map = {
            "critical": "CRITICAL",
            "high": "HIGH",
            "medium": "MEDIUM",
            "low": "LOW",
            "negligible": "NONE",
            "unknown": "NONE",
        }
        return priority_map.get(priority.lower(), "NONE")

    @staticmethod
    def debian_urgency_to_severity(urgency: str) -> str:
        """Convert Debian urgency to severity string."""
        urgency_map = {
            "unimportant": "NONE",
            "low": "LOW",
            "medium": "MEDIUM",
            "high": "HIGH",
            "not yet assigned": "NONE",
        }
        return urgency_map.get(urgency.lower(), "NONE")


class CveFetchers(SeverityConverter):
    """
    Mixin class providing CVE fetching methods for various data sources.

    Requires the parent class to provide:
    - _get_http_client() -> httpx.AsyncClient
    """

    async def _get_http_client(self) -> httpx.AsyncClient:
        """Must be implemented by parent class."""
        raise NotImplementedError

    # -------------------------------------------------------------------------
    # NVD Helper Methods
    # -------------------------------------------------------------------------

    def _extract_nvd_cvss(
        self, metrics: Dict[str, Any]
    ) -> Tuple[Optional[str], Optional[str], str]:
        """Extract CVSS score, version, and severity from NVD metrics."""
        if "cvssMetricV31" in metrics:
            cvss_data = metrics["cvssMetricV31"][0]["cvssData"]
            return (
                str(cvss_data.get("baseScore", "")),
                "3.1",
                cvss_data.get("baseSeverity", "NONE"),
            )
        if "cvssMetricV30" in metrics:
            cvss_data = metrics["cvssMetricV30"][0]["cvssData"]
            return (
                str(cvss_data.get("baseScore", "")),
                "3.0",
                cvss_data.get("baseSeverity", "NONE"),
            )
        if "cvssMetricV2" in metrics:
            cvss_data = metrics["cvssMetricV2"][0]["cvssData"]
            score = cvss_data.get("baseScore", 0)
            return (
                str(score),
                "2.0",
                self.cvss2_to_severity(score),
            )
        return None, None, "NONE"

    def _extract_nvd_description(self, descriptions: List[Dict[str, str]]) -> str:
        """Extract English description from NVD descriptions list."""
        for desc in descriptions:
            if desc.get("lang") == "en":
                return desc.get("value", "")
        return ""

    def _parse_nvd_date(self, date_str: Optional[str]) -> Optional[datetime]:
        """Parse NVD date string to datetime."""
        if not date_str:
            return None
        return datetime.fromisoformat(
            date_str.replace("Z", UTC_TIMEZONE_OFFSET)
        ).replace(tzinfo=None)

    def _upsert_nvd_vulnerability(
        self,
        db: Session,
        cve_id: str,
        description: str,
        cvss_score: Optional[str],
        cvss_version: Optional[str],
        severity: str,
        published_date: Optional[datetime],
        modified_date: Optional[datetime],
        references: List[str],
    ) -> bool:
        """Upsert a vulnerability from NVD. Returns True if new."""
        vuln = db.query(Vulnerability).filter(Vulnerability.cve_id == cve_id).first()
        if vuln:
            vuln.description = description
            vuln.cvss_score = cvss_score
            vuln.cvss_version = cvss_version
            vuln.severity = severity
            vuln.published_date = published_date
            vuln.modified_date = modified_date
            vuln.references = references
            return False

        vuln = Vulnerability(
            cve_id=cve_id,
            description=description,
            cvss_score=cvss_score,
            cvss_version=cvss_version,
            severity=severity,
            published_date=published_date,
            modified_date=modified_date,
            references=references,
        )
        db.add(vuln)
        return True

    def _process_nvd_cve(self, db: Session, cve_item: Dict[str, Any]) -> int:
        """Process a single NVD CVE item. Returns 1 if processed, 0 otherwise."""
        cve_data = cve_item.get("cve", {})
        cve_id = cve_data.get("id")
        if not cve_id:
            return 0

        metrics = cve_data.get("metrics", {})
        cvss_score, cvss_version, severity = self._extract_nvd_cvss(metrics)
        description = self._extract_nvd_description(cve_data.get("descriptions", []))
        published_date = self._parse_nvd_date(cve_data.get("published"))
        modified_date = self._parse_nvd_date(cve_data.get("lastModified"))
        references = [ref.get("url") for ref in cve_data.get("references", [])]

        self._upsert_nvd_vulnerability(
            db,
            cve_id,
            description,
            cvss_score,
            cvss_version,
            severity,
            published_date,
            modified_date,
            references,
        )
        return 1

    async def fetch_nvd_data(
        self, db: Session, api_key: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Fetch CVE data from NVD.

        Args:
            db: Database session
            api_key: Optional NVD API key for higher rate limits

        Returns:
            Dictionary with fetch results
        """
        client = await self._get_http_client()
        base_url = CVE_SOURCES["nvd"]["base_url"]
        vulnerabilities_processed = 0

        end_date = datetime.now(timezone.utc)
        start_date = end_date - timedelta(days=7)
        date_format = f"%Y-%m-%dT%H:%M:%S.000{UTC_TIMEZONE_OFFSET}"

        params = {
            "lastModStartDate": start_date.strftime(date_format),
            "lastModEndDate": end_date.strftime(date_format),
            "resultsPerPage": 500,
            "startIndex": 0,
        }

        headers = {"apiKey": api_key} if api_key else {}

        try:
            max_pages = 100
            for page_count in range(1, max_pages + 1):
                logger.info(
                    "NVD fetch page %d, startIndex=%d", page_count, params["startIndex"]
                )

                response = await client.get(base_url, params=params, headers=headers)
                response.raise_for_status()
                data = response.json()

                cves = data.get("vulnerabilities", [])
                if not cves:
                    logger.info("NVD fetch complete - no more CVEs")
                    break

                for cve_item in cves:
                    vulnerabilities_processed += self._process_nvd_cve(db, cve_item)

                db.commit()

                total_results = data.get("totalResults", 0)
                params["startIndex"] += len(cves)

                if params["startIndex"] >= total_results:
                    logger.info("NVD fetch complete - all CVEs processed")
                    break

                await asyncio.sleep(0.6 if api_key else 6)

        except httpx.HTTPError as e:
            raise CveRefreshError(f"HTTP error fetching NVD data: {e}") from e

        return {
            "vulnerabilities_processed": vulnerabilities_processed,
            "packages_processed": 0,
            "source": "nvd",
        }

    # -------------------------------------------------------------------------
    # Ubuntu Helper Methods
    # -------------------------------------------------------------------------

    def _upsert_ubuntu_vulnerability(
        self, db: Session, cve_id: str, description: str, severity: str
    ) -> Tuple[Vulnerability, bool]:
        """Upsert a vulnerability from Ubuntu. Returns (vuln, is_new)."""
        vuln = db.query(Vulnerability).filter(Vulnerability.cve_id == cve_id).first()
        if vuln:
            return vuln, False

        vuln = Vulnerability(cve_id=cve_id, description=description, severity=severity)
        db.add(vuln)
        db.flush()
        return vuln, True

    def _process_ubuntu_package(
        self, db: Session, vuln: Vulnerability, pkg_name: str, statuses: List[Dict]
    ) -> int:
        """Process Ubuntu package statuses. Returns count of packages added."""
        packages_added = 0
        for status in statuses:
            if status.get("status") != "released":
                continue

            fixed_version = status.get("description", "")
            existing = (
                db.query(PackageVulnerability)
                .filter(
                    PackageVulnerability.vulnerability_id == vuln.id,
                    PackageVulnerability.package_name == pkg_name,
                    PackageVulnerability.package_manager == "apt",
                    PackageVulnerability.source == "ubuntu",
                )
                .first()
            )

            if not existing:
                pkg_vuln = PackageVulnerability(
                    vulnerability_id=vuln.id,
                    package_name=pkg_name,
                    package_manager="apt",
                    fixed_version=fixed_version,
                    source="ubuntu",
                    advisory_ids=[],
                )
                db.add(pkg_vuln)
                packages_added += 1

        return packages_added

    def _process_ubuntu_cve(
        self, db: Session, cve_item: Dict[str, Any]
    ) -> Tuple[int, int]:
        """Process a single Ubuntu CVE. Returns (vulns_processed, pkgs_processed)."""
        cve_id = cve_item.get("id")
        if not cve_id:
            return 0, 0

        description = cve_item.get("description", "")
        priority = cve_item.get("priority", "unknown")
        severity = self.ubuntu_priority_to_severity(priority)

        vuln, is_new = self._upsert_ubuntu_vulnerability(
            db, cve_id, description, severity
        )
        vulns_processed = 1 if is_new else 0
        pkgs_processed = 0

        for pkg_info in cve_item.get("packages", []):
            pkg_name = pkg_info.get("name")
            if pkg_name:
                pkgs_processed += self._process_ubuntu_package(
                    db, vuln, pkg_name, pkg_info.get("statuses", [])
                )

        return vulns_processed, pkgs_processed

    async def fetch_ubuntu_data(self, db: Session) -> Dict[str, Any]:
        """
        Fetch CVE data from Ubuntu Security API.

        Args:
            db: Database session

        Returns:
            Dictionary with fetch results
        """
        client = await self._get_http_client()
        base_url = CVE_SOURCES["ubuntu"]["base_url"]
        vulnerabilities_processed = 0
        packages_processed = 0

        try:
            page_limit = 20
            max_pages = 100
            offset = 0

            for page in range(max_pages):
                params = {"limit": page_limit, "offset": offset}
                logger.info("Ubuntu fetch page %d, offset=%d", page + 1, offset)

                response = await client.get(base_url, params=params)
                response.raise_for_status()
                data = response.json()

                cves = data.get("cves", [])
                if not cves:
                    logger.info("Ubuntu fetch complete - no more CVEs")
                    break

                for cve_item in cves:
                    v_count, p_count = self._process_ubuntu_cve(db, cve_item)
                    vulnerabilities_processed += v_count
                    packages_processed += p_count

                db.commit()

                total_results = data.get("total_results", 0)
                offset += len(cves)
                if offset >= total_results or offset >= 2000:
                    logger.info(
                        "Ubuntu fetch complete: %d/%d CVEs", offset, total_results
                    )
                    break

                await asyncio.sleep(0.5)

        except httpx.HTTPError as e:
            raise CveRefreshError(f"HTTP error fetching Ubuntu data: {e}") from e

        return {
            "vulnerabilities_processed": vulnerabilities_processed,
            "packages_processed": packages_processed,
            "source": "ubuntu",
        }

    # -------------------------------------------------------------------------
    # Debian Helper Methods
    # -------------------------------------------------------------------------

    def _upsert_debian_vulnerability(
        self, thread_db: Session, cve_id: str, description: str, severity: str
    ) -> Tuple[Vulnerability, bool]:
        """Upsert a Debian vulnerability. Returns (vuln, is_new)."""
        vuln = (
            thread_db.query(Vulnerability)
            .filter(Vulnerability.cve_id == cve_id)
            .first()
        )
        if vuln:
            return vuln, False

        vuln = Vulnerability(cve_id=cve_id, description=description, severity=severity)
        thread_db.add(vuln)
        thread_db.flush()
        return vuln, True

    def _process_debian_releases(
        self, thread_db: Session, vuln: Vulnerability, pkg_name: str, releases: Dict
    ) -> int:
        """Process Debian releases for a package. Returns packages added count."""
        packages_added = 0
        for _release, release_info in releases.items():
            fixed_version = release_info.get("fixed_version")
            if not fixed_version:
                continue

            existing = (
                thread_db.query(PackageVulnerability)
                .filter(
                    PackageVulnerability.vulnerability_id == vuln.id,
                    PackageVulnerability.package_name == pkg_name,
                    PackageVulnerability.package_manager == "apt",
                    PackageVulnerability.source == "debian",
                )
                .first()
            )

            if not existing:
                pkg_vuln = PackageVulnerability(
                    vulnerability_id=vuln.id,
                    package_name=pkg_name,
                    package_manager="apt",
                    fixed_version=fixed_version,
                    source="debian",
                )
                thread_db.add(pkg_vuln)
                packages_added += 1

        return packages_added

    def _process_debian_data_sync(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Process Debian CVE data synchronously in a background thread.

        Args:
            data: Parsed JSON data from Debian Security Tracker

        Returns:
            Dictionary with processing results
        """
        session_factory = sessionmaker(bind=db_module.get_engine())
        thread_db = session_factory()
        vulnerabilities_processed = 0
        packages_processed = 0

        try:
            for pkg_name, pkg_data in data.items():
                for cve_id, cve_info in pkg_data.items():
                    if not cve_id.startswith("CVE-"):
                        continue

                    urgency = cve_info.get("urgency", "unimportant")
                    severity = self.debian_urgency_to_severity(urgency)
                    description = cve_info.get("description", "")

                    vuln, is_new = self._upsert_debian_vulnerability(
                        thread_db, cve_id, description, severity
                    )
                    if is_new:
                        vulnerabilities_processed += 1

                    releases = cve_info.get("releases", {})
                    packages_processed += self._process_debian_releases(
                        thread_db, vuln, pkg_name, releases
                    )

            thread_db.commit()
        finally:
            thread_db.close()

        return {
            "vulnerabilities_processed": vulnerabilities_processed,
            "packages_processed": packages_processed,
            "source": "debian",
        }

    async def fetch_debian_data(self, _db: Session) -> Dict[str, Any]:
        """
        Fetch CVE data from Debian Security Tracker.

        Args:
            _db: Database session (unused - thread creates its own session)

        Returns:
            Dictionary with fetch results
        """
        client = await self._get_http_client()
        base_url = CVE_SOURCES["debian"]["base_url"]

        try:
            response = await client.get(base_url)
            response.raise_for_status()
            data = response.json()

            loop = asyncio.get_event_loop()
            result = await loop.run_in_executor(
                None, self._process_debian_data_sync, data
            )
            return result

        except httpx.HTTPError as e:
            raise CveRefreshError(f"HTTP error fetching Debian data: {e}") from e

    # -------------------------------------------------------------------------
    # Red Hat Helper Methods
    # -------------------------------------------------------------------------

    def _parse_redhat_severity(self, raw_severity: Optional[str]) -> str:
        """Parse Red Hat severity to standard format."""
        if not raw_severity:
            return "NONE"
        severity = raw_severity.upper()
        return severity if severity in ["CRITICAL", "HIGH", "MEDIUM", "LOW"] else "NONE"

    def _parse_redhat_date(self, date_str: Optional[str]) -> Optional[datetime]:
        """Parse Red Hat date string."""
        if not date_str:
            return None
        try:
            return datetime.fromisoformat(
                date_str.replace("Z", UTC_TIMEZONE_OFFSET)
            ).replace(tzinfo=None)
        except ValueError:
            return None

    def _upsert_redhat_vulnerability(
        self, db: Session, cve_item: Dict[str, Any]
    ) -> Tuple[Optional[Vulnerability], bool]:
        """Upsert a Red Hat vulnerability. Returns (vuln, is_new) or (None, False)."""
        cve_id = cve_item.get("CVE")
        if not cve_id:
            return None, False

        severity = self._parse_redhat_severity(cve_item.get("severity"))
        cvss_score = str(cve_item.get("cvss3_score", ""))
        published_date = self._parse_redhat_date(cve_item.get("public_date"))

        vuln = db.query(Vulnerability).filter(Vulnerability.cve_id == cve_id).first()
        if vuln:
            return vuln, False

        vuln = Vulnerability(
            cve_id=cve_id,
            cvss_score=cvss_score,
            cvss_version="3.1" if cvss_score else None,
            severity=severity,
            published_date=published_date,
        )
        db.add(vuln)
        db.flush()
        return vuln, True

    def _process_redhat_packages(
        self, db: Session, vuln: Vulnerability, packages: List[str]
    ) -> int:
        """Process Red Hat affected packages. Returns count added."""
        packages_added = 0
        for pkg in packages:
            existing = (
                db.query(PackageVulnerability)
                .filter(
                    PackageVulnerability.vulnerability_id == vuln.id,
                    PackageVulnerability.package_name == pkg,
                    PackageVulnerability.package_manager == "dnf",
                    PackageVulnerability.source == "redhat",
                )
                .first()
            )

            if not existing:
                pkg_vuln = PackageVulnerability(
                    vulnerability_id=vuln.id,
                    package_name=pkg,
                    package_manager="dnf",
                    source="redhat",
                )
                db.add(pkg_vuln)
                packages_added += 1

        return packages_added

    async def fetch_redhat_data(self, db: Session) -> Dict[str, Any]:
        """
        Fetch CVE data from Red Hat Security Data API.

        Args:
            db: Database session

        Returns:
            Dictionary with fetch results
        """
        client = await self._get_http_client()
        base_url = CVE_SOURCES["redhat"]["base_url"]
        vulnerabilities_processed = 0
        packages_processed = 0

        try:
            end_date = datetime.now(timezone.utc).strftime("%Y-%m-%d")
            start_date = (datetime.now(timezone.utc) - timedelta(days=30)).strftime(
                "%Y-%m-%d"
            )

            params = {"after": start_date, "before": end_date, "per_page": 1000}

            response = await client.get(base_url, params=params)
            response.raise_for_status()
            cves = response.json()

            for cve_item in cves:
                vuln, is_new = self._upsert_redhat_vulnerability(db, cve_item)
                if vuln is None:
                    continue
                if is_new:
                    vulnerabilities_processed += 1

                affected_packages = cve_item.get("affected_packages", [])
                packages_processed += self._process_redhat_packages(
                    db, vuln, affected_packages
                )

            db.commit()

        except httpx.HTTPError as e:
            raise CveRefreshError(f"HTTP error fetching Red Hat data: {e}") from e

        return {
            "vulnerabilities_processed": vulnerabilities_processed,
            "packages_processed": packages_processed,
            "source": "redhat",
        }

    # -------------------------------------------------------------------------
    # Microsoft Helper Methods
    # -------------------------------------------------------------------------

    def _extract_msrc_description(
        self, vuln_elem: Any, namespaces: Dict[str, str]
    ) -> str:
        """Extract description from MSRC vulnerability element."""
        title_elem = vuln_elem.find("vuln:Title", namespaces)
        description = title_elem.text if title_elem is not None else ""

        for note in vuln_elem.findall("vuln:Notes/vuln:Note", namespaces):
            if note.get("Type") == "Description" and note.text:
                return note.text

        return description

    def _extract_msrc_cvss(
        self, vuln_elem: Any, namespaces: Dict[str, str]
    ) -> Tuple[Optional[str], str]:
        """Extract CVSS score and severity from MSRC vulnerability."""
        for score_set in vuln_elem.findall(
            ".//vuln:CVSSScoreSets/vuln:ScoreSetV3", namespaces
        ):
            base_score_elem = score_set.find("vuln:BaseScore", namespaces)
            if base_score_elem is not None and base_score_elem.text:
                try:
                    cvss_score = base_score_elem.text.strip()
                    severity = self.cvss3_to_severity(float(cvss_score))
                    return cvss_score, severity
                except ValueError:
                    pass
        return None, "NONE"

    def _upsert_msrc_vulnerability(
        self,
        db: Session,
        cve_id: str,
        description: str,
        cvss_score: Optional[str],
        severity: str,
    ) -> Tuple[Vulnerability, bool]:
        """Upsert a Microsoft vulnerability. Returns (vuln, is_new)."""
        vuln = db.query(Vulnerability).filter(Vulnerability.cve_id == cve_id).first()
        if vuln:
            return vuln, False

        vuln = Vulnerability(
            cve_id=cve_id,
            description=description[:4000] if description else None,
            cvss_score=cvss_score,
            cvss_version="3.1" if cvss_score else None,
            severity=severity,
        )
        db.add(vuln)
        db.flush()
        return vuln, True

    def _process_msrc_products(
        self,
        db: Session,
        vuln: Vulnerability,
        vuln_elem: Any,
        namespaces: Dict[str, str],
    ) -> int:
        """Process MSRC affected products. Returns count added."""
        packages_added = 0
        for product_status in vuln_elem.findall(
            ".//vuln:ProductStatuses/vuln:Status", namespaces
        ):
            if product_status.get("Type") != "Known Affected":
                continue

            for product_id in product_status.findall("vuln:ProductID", namespaces):
                if not product_id.text:
                    continue

                product_name = product_id.text.strip()
                existing = (
                    db.query(PackageVulnerability)
                    .filter(
                        PackageVulnerability.vulnerability_id == vuln.id,
                        PackageVulnerability.package_name == product_name,
                        PackageVulnerability.source == "microsoft",
                    )
                    .first()
                )

                if not existing:
                    pkg_vuln = PackageVulnerability(
                        vulnerability_id=vuln.id,
                        package_name=product_name,
                        package_manager="windows",
                        source="microsoft",
                    )
                    db.add(pkg_vuln)
                    packages_added += 1

        return packages_added

    def _process_msrc_vulnerability(
        self, db: Session, vuln_elem: Any, namespaces: Dict[str, str]
    ) -> Tuple[int, int]:
        """Process a single MSRC vulnerability element. Returns (vulns, pkgs) counts."""
        cve_elem = vuln_elem.find("vuln:CVE", namespaces)
        if cve_elem is None or not cve_elem.text:
            return 0, 0

        cve_id = cve_elem.text.strip()
        description = self._extract_msrc_description(vuln_elem, namespaces)
        cvss_score, severity = self._extract_msrc_cvss(vuln_elem, namespaces)

        vuln, is_new = self._upsert_msrc_vulnerability(
            db, cve_id, description, cvss_score, severity
        )
        vulns_processed = 1 if is_new else 0
        pkgs_processed = self._process_msrc_products(db, vuln, vuln_elem, namespaces)

        return vulns_processed, pkgs_processed

    async def _process_msrc_cvrf(
        self,
        db: Session,
        client: httpx.AsyncClient,
        update: Dict[str, Any],
        namespaces: Dict[str, str],
    ) -> Tuple[int, int]:
        """Process a single MSRC CVRF document. Returns (vulns, pkgs) counts."""
        update_id = update.get("ID", "")
        cvrf_url = update.get("CvrfUrl", "")

        if not cvrf_url:
            return 0, 0

        logger.info("Fetching Microsoft CVRF: %s", update_id)
        vulns_processed = 0
        pkgs_processed = 0

        try:
            cvrf_response = await client.get(cvrf_url)
            cvrf_response.raise_for_status()
            root = ET.fromstring(cvrf_response.text)

            for vuln_elem in root.findall(".//vuln:Vulnerability", namespaces):
                v_count, p_count = self._process_msrc_vulnerability(
                    db, vuln_elem, namespaces
                )
                vulns_processed += v_count
                pkgs_processed += p_count

            db.commit()

        except ET.ParseError as e:
            logger.warning("Failed to parse Microsoft CVRF %s: %s", update_id, e)
        except httpx.HTTPError as e:
            logger.warning("Failed to fetch Microsoft CVRF %s: %s", update_id, e)

        return vulns_processed, pkgs_processed

    async def fetch_microsoft_data(self, db: Session) -> Dict[str, Any]:
        """
        Fetch CVE data from Microsoft Security Response Center (MSRC).

        Args:
            db: Database session

        Returns:
            Dictionary with fetch results
        """
        client = await self._get_http_client()
        base_url = CVE_SOURCES["microsoft"]["base_url"]
        vulnerabilities_processed = 0
        packages_processed = 0

        # NOSONAR - These are XML namespace URIs (identifiers), not HTTP connections.
        # XML namespaces use http:// URIs as standard identifiers per W3C spec.
        namespaces = {
            "cvrf": "http://docs.oasis-open.org/csaf/ns/csaf-cvrf/v1.2/cvrf",  # NOSONAR
            "vuln": "http://docs.oasis-open.org/csaf/ns/csaf-cvrf/v1.2/vuln",  # NOSONAR
            "prod": "http://docs.oasis-open.org/csaf/ns/csaf-cvrf/v1.2/prod",  # NOSONAR
        }

        try:
            response = await client.get(f"{base_url}/updates")
            response.raise_for_status()
            updates_data = response.json()

            updates = updates_data.get("value", [])
            if not updates:
                logger.warning("No Microsoft security updates found")
                return {
                    "vulnerabilities_processed": 0,
                    "packages_processed": 0,
                    "source": "microsoft",
                }

            recent_updates = sorted(
                updates, key=lambda x: x.get("CurrentReleaseDate", ""), reverse=True
            )[:3]

            for update in recent_updates:
                v_count, p_count = await self._process_msrc_cvrf(
                    db, client, update, namespaces
                )
                vulnerabilities_processed += v_count
                packages_processed += p_count
                await asyncio.sleep(1)

        except httpx.HTTPError as e:
            raise CveRefreshError(f"HTTP error fetching Microsoft data: {e}") from e

        return {
            "vulnerabilities_processed": vulnerabilities_processed,
            "packages_processed": packages_processed,
            "source": "microsoft",
        }

    # -------------------------------------------------------------------------
    # FreeBSD
    # -------------------------------------------------------------------------

    def fetch_freebsd_data(self, _db: Session) -> Dict[str, Any]:
        """
        Fetch CVE data from FreeBSD VuXML.

        Args:
            _db: Database session (unused - not yet implemented)

        Returns:
            Dictionary with fetch results
        """
        logger.info("FreeBSD VuXML source not yet implemented")
        return {
            "vulnerabilities_processed": 0,
            "packages_processed": 0,
            "source": "freebsd",
            "details": {"message": "FreeBSD VuXML parsing not yet implemented"},
        }
