"""
CVE Database Refresh Service - Thin Wrapper.

This is a thin wrapper that delegates to the vuln_engine Cython module.
CVE refresh requires a Pro+ license with the vuln_engine module.
"""

from datetime import datetime, timedelta, timezone
from typing import Any, Dict, List, Optional

from backend.licensing.features import ModuleCode
from backend.licensing.license_service import license_service
from backend.licensing.module_loader import module_loader
from backend.persistence import db as db_module
from backend.persistence import models
from backend.utils.verbosity_logger import get_logger

from .cve_fetchers import CveFetchers
from .cve_sources import CVE_SOURCES, CveRefreshError

logger = get_logger("backend.vulnerability.cve_refresh_service")

# Re-export for backwards compatibility
__all__ = ["CveRefreshService", "CveRefreshError", "CVE_SOURCES", "cve_refresh_service"]


def _get_module():
    """Get the vuln_engine module or None."""
    if not license_service.has_module(ModuleCode.VULN_ENGINE):
        return None
    return module_loader.get_module("vuln_engine")


class CveRefreshService(CveFetchers):
    """
    Service for managing CVE database refresh operations.
    Delegates to vuln_engine module.
    """

    def __init__(self):
        self._module_configured = False

    def _ensure_module_configured(self):
        """Configure the module service if not already done."""
        if self._module_configured:
            return

        vuln_engine = _get_module()
        if vuln_engine and hasattr(vuln_engine, "_cve_refresh_service"):
            vuln_engine._cve_refresh_service.configure(
                db_module.get_engine(), models, logger
            )
            self._module_configured = True

    def get_settings(self, db):
        """Get or create CVE refresh settings."""
        self._ensure_module_configured()
        vuln_engine = _get_module()
        if vuln_engine and hasattr(vuln_engine, "_cve_refresh_service"):
            return vuln_engine._cve_refresh_service.get_settings(db)
        raise CveRefreshError("vuln_engine module required for CVE refresh settings")

    def update_settings(
        self,
        db,
        enabled: Optional[bool] = None,
        refresh_interval_hours: Optional[int] = None,
        enabled_sources: Optional[List[str]] = None,
        nvd_api_key: Optional[str] = None,
    ):
        """Update CVE refresh settings."""
        self._ensure_module_configured()
        vuln_engine = _get_module()
        if vuln_engine and hasattr(vuln_engine, "_cve_refresh_service"):
            return vuln_engine._cve_refresh_service.update_settings(
                db, enabled, refresh_interval_hours, enabled_sources, nvd_api_key
            )
        raise CveRefreshError("vuln_engine module required for CVE refresh settings")

    def get_available_sources(self) -> Dict[str, Any]:
        """Get list of available CVE sources with descriptions."""
        vuln_engine = _get_module()
        if vuln_engine and hasattr(vuln_engine, "_cve_refresh_service"):
            return vuln_engine._cve_refresh_service.get_available_sources()
        return CVE_SOURCES.copy()

    def get_ingestion_history(self, db, limit: int = 10) -> List:
        """Get recent CVE ingestion history."""
        self._ensure_module_configured()
        vuln_engine = _get_module()
        if vuln_engine and hasattr(vuln_engine, "_cve_refresh_service"):
            return vuln_engine._cve_refresh_service.get_ingestion_history(db, limit)
        raise CveRefreshError("vuln_engine module required for CVE ingestion history")

    def get_database_stats(self, db) -> Dict[str, Any]:
        """Get CVE database statistics."""
        self._ensure_module_configured()
        vuln_engine = _get_module()
        if vuln_engine and hasattr(vuln_engine, "_cve_refresh_service"):
            return vuln_engine._cve_refresh_service.get_database_stats(db)
        raise CveRefreshError("vuln_engine module required for CVE database stats")

    async def refresh_from_source(
        self, db, source: str, nvd_api_key: Optional[str] = None
    ) -> Dict[str, Any]:
        """Refresh CVE data from a specific source."""
        self._ensure_module_configured()
        vuln_engine = _get_module()
        if vuln_engine and hasattr(vuln_engine, "_cve_refresh_service"):
            return await vuln_engine._cve_refresh_service.refresh_from_source(
                db, source, nvd_api_key
            )
        raise CveRefreshError("vuln_engine module required for CVE refresh")

    async def refresh_all(self, db) -> Dict[str, Any]:
        """Refresh CVE data from all enabled sources."""
        self._ensure_module_configured()
        vuln_engine = _get_module()
        if vuln_engine and hasattr(vuln_engine, "_cve_refresh_service"):
            return await vuln_engine._cve_refresh_service.refresh_all(db)
        raise CveRefreshError("vuln_engine module required for CVE refresh")

    async def check_and_refresh_if_overdue(self, db_maker):
        """
        Check if the CVE database refresh is overdue and trigger a refresh
        if needed. Also cleans up orphaned "running" ingestion log records
        from previous server instances. Intended to be called during
        application startup.

        Args:
            db_maker: Database session generator (e.g. get_db)
        """
        logger.info("=== CVE REFRESH STALENESS CHECK ===")
        db = None
        try:
            db_gen = db_maker()
            db = next(db_gen)

            # Clean up orphaned "running" ingestion log records from
            # previous server instances that may have crashed or been
            # restarted mid-refresh.
            try:
                orphaned = (
                    db.query(models.VulnerabilityIngestionLog)
                    .filter(models.VulnerabilityIngestionLog.status == "running")
                    .all()
                )
                if orphaned:
                    now_naive = datetime.now(timezone.utc).replace(tzinfo=None)
                    for record in orphaned:
                        logger.warning(
                            "Cleaning up orphaned 'running' ingestion log: "
                            "source=%s, started_at=%s",
                            record.source,
                            record.started_at,
                        )
                        record.status = "error"
                        record.completed_at = now_naive
                        record.error_message = (
                            "Marked as error during startup cleanup "
                            "(server restarted while refresh was in progress)"
                        )
                    db.commit()
                    logger.info(
                        "Cleaned up %d orphaned ingestion log records",
                        len(orphaned),
                    )
            except Exception as cleanup_e:
                logger.warning(
                    "Failed to clean up orphaned ingestion logs: %s", cleanup_e
                )
                db.rollback()

            settings = self.get_settings(db)
            if not settings.enabled:
                logger.info("CVE refresh is disabled, skipping staleness check")
                return

            # Use offset-naive UTC to match database datetime convention
            now = datetime.now(timezone.utc).replace(tzinfo=None)
            interval = timedelta(hours=settings.refresh_interval_hours)

            if settings.last_refresh_at is None:
                logger.info("CVE refresh has never run, triggering initial refresh")
                is_overdue = True
            elif settings.last_refresh_at + interval < now:
                overdue_by = now - (settings.last_refresh_at + interval)
                logger.info(
                    "CVE refresh is overdue by %s, triggering background refresh",
                    overdue_by,
                )
                is_overdue = True
            else:
                next_due = settings.last_refresh_at + interval
                logger.info(
                    "CVE refresh is current, next refresh due at %s",
                    next_due.isoformat(),
                )
                is_overdue = False

            if is_overdue:
                logger.info("Starting overdue CVE refresh from all enabled sources")
                result = await self.refresh_all(db)
                logger.info(
                    "Overdue CVE refresh completed: %d vulnerabilities, %d packages",
                    result.get("total_vulnerabilities", 0),
                    result.get("total_packages", 0),
                )
        except Exception as e:
            logger.warning("CVE staleness check failed: %s", e)
        finally:
            if db is not None:
                try:
                    db.close()
                except (
                    Exception
                ):  # nosec B110  # db.close() failure in cleanup is non-actionable
                    pass

    def start_scheduler(self):
        """Start the background scheduler for automatic CVE refresh."""
        self._ensure_module_configured()
        vuln_engine = _get_module()
        if vuln_engine and hasattr(vuln_engine, "_cve_refresh_service"):
            vuln_engine._cve_refresh_service.start_scheduler()
            return
        logger.warning("CVE refresh scheduler requires vuln_engine module")

    async def stop_scheduler(self):
        """Stop the background scheduler."""
        vuln_engine = _get_module()
        if vuln_engine and hasattr(vuln_engine, "_cve_refresh_service"):
            await vuln_engine._cve_refresh_service.stop_scheduler()


# Singleton instance
cve_refresh_service = CveRefreshService()
