"""
CVE Database Refresh Service for SysManage.

This service fetches vulnerability data from multiple sources and stores it
in the database. Supports scheduling and manual refresh triggers.

Supported Sources:
- NVD (National Vulnerability Database) - Primary CVE source
- Ubuntu Security API - Ubuntu-specific advisories and fixes
- Debian Security Tracker - Debian-specific advisories
- Red Hat Security Data API - Red Hat/CentOS advisories
- Microsoft Security Response Center - Windows/Microsoft vulnerabilities
- FreeBSD VuXML - FreeBSD vulnerabilities
"""

import asyncio
import logging
from datetime import datetime, timedelta, timezone
from typing import Any, Dict, List, Optional

import httpx
from sqlalchemy import func
from sqlalchemy.orm import Session, sessionmaker

from backend.persistence import db as db_module
from backend.persistence.models import (
    CveRefreshSettings,
    PackageVulnerability,
    Vulnerability,
    VulnerabilityIngestionLog,
)

from .cve_fetchers import CveFetchers
from .cve_sources import CVE_SOURCES, CveRefreshError

logger = logging.getLogger(__name__)

# Re-export for backwards compatibility
__all__ = ["CveRefreshService", "CveRefreshError", "CVE_SOURCES", "cve_refresh_service"]


class CveRefreshService(CveFetchers):
    """
    Service for managing CVE database refresh operations.
    Fetches vulnerability data from multiple sources and stores in database.
    """

    def __init__(self):
        self._refresh_task: Optional[asyncio.Task] = None
        self._is_running = False
        self._http_client: Optional[httpx.AsyncClient] = None

    async def _get_http_client(self) -> httpx.AsyncClient:
        """Get or create async HTTP client."""
        if self._http_client is None or self._http_client.is_closed:
            self._http_client = httpx.AsyncClient(
                timeout=httpx.Timeout(60.0, connect=10.0),
                follow_redirects=True,
                headers={"User-Agent": "SysManage-CveRefresh/1.0"},
            )
        return self._http_client

    def get_settings(self, db: Session) -> CveRefreshSettings:
        """
        Get or create CVE refresh settings.

        Args:
            db: Database session

        Returns:
            CveRefreshSettings instance
        """
        settings = db.query(CveRefreshSettings).first()
        if not settings:
            # Create default settings
            now = datetime.now(timezone.utc).replace(tzinfo=None)
            settings = CveRefreshSettings(
                enabled=True,
                refresh_interval_hours=24,
                enabled_sources=["nvd", "ubuntu", "debian", "redhat"],
                created_at=now,
                updated_at=now,
            )
            db.add(settings)
            db.commit()
            db.refresh(settings)
        return settings

    def _validate_refresh_interval(self, hours: int) -> None:
        """Validate refresh interval hours."""
        if hours < 1:
            raise ValueError("Refresh interval must be at least 1 hour")
        if hours > 168:  # Max 1 week
            raise ValueError("Refresh interval cannot exceed 168 hours (1 week)")

    def _validate_sources(self, sources: List[str]) -> None:
        """Validate CVE source names."""
        for source in sources:
            if source not in CVE_SOURCES:
                raise ValueError(f"Invalid CVE source: {source}")

    def update_settings(
        self,
        db: Session,
        enabled: Optional[bool] = None,
        refresh_interval_hours: Optional[int] = None,
        enabled_sources: Optional[List[str]] = None,
        nvd_api_key: Optional[str] = None,
    ) -> CveRefreshSettings:
        """
        Update CVE refresh settings.

        Args:
            db: Database session
            enabled: Enable/disable automatic refresh
            refresh_interval_hours: Refresh interval in hours
            enabled_sources: List of enabled source names
            nvd_api_key: Optional NVD API key

        Returns:
            Updated CveRefreshSettings
        """
        settings = self.get_settings(db)

        if enabled is not None:
            settings.enabled = enabled
        if refresh_interval_hours is not None:
            self._validate_refresh_interval(refresh_interval_hours)
            settings.refresh_interval_hours = refresh_interval_hours
        if enabled_sources is not None:
            self._validate_sources(enabled_sources)
            settings.enabled_sources = enabled_sources
        if nvd_api_key is not None:
            settings.nvd_api_key = nvd_api_key if nvd_api_key.strip() else None

        settings.updated_at = datetime.now(timezone.utc).replace(tzinfo=None)

        # Update next refresh time
        if settings.enabled and settings.last_refresh_at:
            settings.next_refresh_at = settings.last_refresh_at + timedelta(
                hours=settings.refresh_interval_hours
            )

        db.commit()
        db.refresh(settings)
        return settings

    def get_available_sources(self) -> Dict[str, Any]:
        """
        Get list of available CVE sources with descriptions.

        Returns:
            Dictionary of available sources
        """
        return CVE_SOURCES.copy()

    def get_ingestion_history(
        self, db: Session, limit: int = 10
    ) -> List[VulnerabilityIngestionLog]:
        """
        Get recent CVE ingestion history.

        Args:
            db: Database session
            limit: Maximum number of records to return

        Returns:
            List of VulnerabilityIngestionLog records
        """
        return (
            db.query(VulnerabilityIngestionLog)
            .order_by(VulnerabilityIngestionLog.started_at.desc())
            .limit(limit)
            .all()
        )

    def get_database_stats(self, db: Session) -> Dict[str, Any]:
        """
        Get CVE database statistics.

        Args:
            db: Database session

        Returns:
            Dictionary with database statistics
        """
        # pylint: disable=not-callable
        total_cves = db.query(func.count(Vulnerability.id)).scalar() or 0
        total_packages = db.query(func.count(PackageVulnerability.id)).scalar() or 0
        # Count by severity
        severity_counts = {}
        for severity in ["CRITICAL", "HIGH", "MEDIUM", "LOW", "NONE"]:
            count = (
                db.query(func.count(Vulnerability.id))  # pylint: disable=not-callable
                .filter(Vulnerability.severity == severity)
                .scalar()
                or 0
            )
            severity_counts[severity.lower()] = count

        # Get last refresh info
        settings = self.get_settings(db)
        last_log = (
            db.query(VulnerabilityIngestionLog)
            .filter(VulnerabilityIngestionLog.status == "success")
            .order_by(VulnerabilityIngestionLog.completed_at.desc())
            .first()
        )

        return {
            "total_cves": total_cves,
            "total_package_mappings": total_packages,
            "severity_counts": severity_counts,
            "last_refresh_at": settings.last_refresh_at,
            "next_refresh_at": settings.next_refresh_at,
            "last_successful_ingestion": (
                {
                    "source": last_log.source,
                    "completed_at": last_log.completed_at,
                    "vulnerabilities_processed": last_log.vulnerabilities_processed,
                }
                if last_log
                else None
            ),
        }

    async def refresh_from_source(
        self, db: Session, source: str, nvd_api_key: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Refresh CVE data from a specific source.

        Args:
            db: Database session
            source: Source name (nvd, ubuntu, debian, etc.)
            nvd_api_key: Optional NVD API key

        Returns:
            Dictionary with refresh results
        """
        if source not in CVE_SOURCES:
            raise CveRefreshError(f"Unknown CVE source: {source}")

        # Create ingestion log
        started_at = datetime.now(timezone.utc).replace(tzinfo=None)
        log = VulnerabilityIngestionLog(
            source=source,
            started_at=started_at,
            status="running",
        )
        db.add(log)
        db.commit()
        db.refresh(log)

        try:
            # Fetch and process data based on source
            if source == "nvd":
                result = await self.fetch_nvd_data(db, nvd_api_key)
            elif source == "ubuntu":
                result = await self.fetch_ubuntu_data(db)
            elif source == "debian":
                result = await self.fetch_debian_data(db)
            elif source == "redhat":
                result = await self.fetch_redhat_data(db)
            elif source == "microsoft":
                result = await self.fetch_microsoft_data(db)
            elif source == "freebsd":
                result = await self.fetch_freebsd_data(db)
            else:
                raise CveRefreshError(f"Source {source} not implemented")

            # Update log with success
            log.status = "success"
            log.completed_at = datetime.now(timezone.utc).replace(tzinfo=None)
            log.vulnerabilities_processed = result.get("vulnerabilities_processed", 0)
            log.packages_processed = result.get("packages_processed", 0)
            log.details = result.get("details")
            db.commit()

            return result

        except Exception as e:
            # Update log with failure
            log.status = "failed"
            log.completed_at = datetime.now(timezone.utc).replace(tzinfo=None)
            log.error_message = str(e)
            db.commit()
            raise CveRefreshError(f"Failed to refresh from {source}: {e}") from e

    async def refresh_all(self, db: Session) -> Dict[str, Any]:
        """
        Refresh CVE data from all enabled sources.

        Args:
            db: Database session

        Returns:
            Dictionary with combined refresh results
        """
        settings = self.get_settings(db)
        results = {
            "started_at": datetime.now(timezone.utc).isoformat(),
            "sources": {},
            "total_vulnerabilities": 0,
            "total_packages": 0,
            "errors": [],
        }

        for source in settings.enabled_sources:
            try:
                result = await self.refresh_from_source(
                    db, source, settings.nvd_api_key
                )
                results["sources"][source] = {
                    "status": "success",
                    "vulnerabilities_processed": result.get(
                        "vulnerabilities_processed", 0
                    ),
                    "packages_processed": result.get("packages_processed", 0),
                }
                results["total_vulnerabilities"] += result.get(
                    "vulnerabilities_processed", 0
                )
                results["total_packages"] += result.get("packages_processed", 0)
            except CveRefreshError as e:
                results["sources"][source] = {"status": "failed", "error": str(e)}
                results["errors"].append(f"{source}: {e}")
                logger.error("Failed to refresh from %s: %s", source, e)

        # Update last refresh timestamp
        settings.last_refresh_at = datetime.now(timezone.utc).replace(tzinfo=None)
        settings.next_refresh_at = settings.last_refresh_at + timedelta(
            hours=settings.refresh_interval_hours
        )
        db.commit()

        results["completed_at"] = datetime.now(timezone.utc).isoformat()
        return results

    def start_scheduler(self):
        """Start the background scheduler for automatic CVE refresh."""
        if self._refresh_task is not None:
            logger.warning("CVE refresh scheduler already running")
            return

        self._is_running = True
        self._refresh_task = asyncio.create_task(self._scheduler_loop())
        logger.info("CVE refresh scheduler started")

    async def stop_scheduler(self):
        """Stop the background scheduler."""
        self._is_running = False
        if self._refresh_task:
            self._refresh_task.cancel()
            # Use gather with return_exceptions to handle CancelledError without re-raising
            await asyncio.gather(self._refresh_task, return_exceptions=True)
            self._refresh_task = None

        if self._http_client and not self._http_client.is_closed:
            await self._http_client.aclose()
            self._http_client = None

        logger.info("CVE refresh scheduler stopped")

    def _should_refresh(self, settings: CveRefreshSettings) -> bool:
        """Determine if a refresh should be triggered based on settings."""
        if settings.next_refresh_at is None:
            return True
        now = datetime.now(timezone.utc).replace(tzinfo=None)
        return now >= settings.next_refresh_at

    async def _scheduler_loop(self):
        """Background loop for scheduled CVE refresh."""
        while self._is_running:
            try:
                # Create a new database session for the scheduler
                session_local = sessionmaker(
                    autocommit=False, autoflush=False, bind=db_module.get_engine()
                )

                with session_local() as db:
                    settings = self.get_settings(db)

                    if not settings.enabled:
                        # Scheduler disabled, wait and check again
                        await asyncio.sleep(60)
                        continue

                    if self._should_refresh(settings):
                        logger.info("Starting scheduled CVE database refresh")
                        try:
                            result = await self.refresh_all(db)
                            logger.info(
                                "Scheduled CVE refresh completed: %d vulnerabilities, %d packages",
                                result["total_vulnerabilities"],
                                result["total_packages"],
                            )
                        except Exception as e:
                            logger.error("Scheduled CVE refresh failed: %s", e)

                    # Calculate sleep time until next check (check every minute)
                    await asyncio.sleep(60)

            except asyncio.CancelledError:
                logger.debug("Scheduler loop cancelled")
                raise
            except Exception as e:
                logger.error("Error in CVE refresh scheduler: %s", e)
                await asyncio.sleep(60)


# Singleton instance
cve_refresh_service = CveRefreshService()
