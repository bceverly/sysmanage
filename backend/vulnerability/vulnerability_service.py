"""
Vulnerability scanning service for Pro+ hosts.

Orchestrates vulnerability scanning using the vuln_engine module
and stores results in the database.
"""

from datetime import datetime, timezone
from typing import Any, Dict, List, Optional

from sqlalchemy.orm import Session, sessionmaker

from backend.licensing.features import ModuleCode
from backend.licensing.license_service import license_service
from backend.licensing.module_loader import module_loader
from backend.persistence import db as db_module
from backend.persistence.models import (
    Host,
    HostVulnerabilityFinding,
    HostVulnerabilityScan,
    PackageVulnerability,
    SoftwarePackage,
    Vulnerability,
)
from backend.utils.verbosity_logger import get_logger

logger = get_logger("backend.vulnerability.vulnerability_service")


class VulnerabilityServiceError(Exception):
    """Exception raised when vulnerability operations fail."""


class VulnerabilityService:
    """
    Service for performing vulnerability scans on hosts.
    """

    def _get_risk_level(self, risk_score: int) -> str:
        """Convert risk score to risk level label."""
        if risk_score >= 75:
            return "CRITICAL"
        elif risk_score >= 50:
            return "HIGH"
        elif risk_score >= 25:
            return "MEDIUM"
        elif risk_score > 0:
            return "LOW"
        return "NONE"

    def _gather_host_packages(self, db: Session, host_id: str) -> List[Dict[str, Any]]:
        """
        Gather installed packages for a host.

        Args:
            db: Database session
            host_id: The host ID

        Returns:
            List of package dictionaries for analysis
        """
        host = db.query(Host).filter(Host.id == host_id).first()
        if not host:
            raise VulnerabilityServiceError(f"Host not found: {host_id}")

        packages = (
            db.query(SoftwarePackage).filter(SoftwarePackage.host_id == host_id).all()
        )

        return [
            {
                "name": pkg.package_name,
                "version": pkg.package_version,
                "package_manager": pkg.package_manager,
                "architecture": pkg.architecture,
            }
            for pkg in packages
        ]

    def _get_vulnerability_data(
        self, db: Session, package_managers: List[str]
    ) -> List[Dict[str, Any]]:
        """
        Get vulnerability data for the specified package managers.

        Args:
            db: Database session
            package_managers: List of package manager types to filter

        Returns:
            List of vulnerability dictionaries for scanning
        """
        package_vulns = (
            db.query(PackageVulnerability)
            .filter(PackageVulnerability.package_manager.in_(package_managers))
            .all()
        )

        result = []
        for pv in package_vulns:
            vuln = pv.vulnerability
            if vuln:
                result.append(
                    {
                        "cve_id": vuln.cve_id,
                        "package_name": pv.package_name,
                        "package_manager": pv.package_manager,
                        "vulnerable_versions": pv.vulnerable_versions or "all",
                        "fixed_version": pv.fixed_version,
                        "cvss_score": (
                            float(vuln.cvss_score)
                            if vuln.cvss_score and vuln.cvss_score != "N/A"
                            else 0.0
                        ),
                        "severity": vuln.severity or "UNKNOWN",
                        "description": vuln.description,
                        "references": vuln.references or [],
                        "published_date": (
                            vuln.published_date.isoformat()
                            if vuln.published_date
                            else None
                        ),
                        "advisory_ids": pv.advisory_ids or [],
                    }
                )

        return result

    def scan_host(self, host_id: str) -> Dict[str, Any]:
        """
        Perform vulnerability scan on a host.

        Args:
            host_id: The host ID to scan

        Returns:
            Dictionary with scan results

        Raises:
            VulnerabilityServiceError: If scan fails
        """
        # Check if vuln_engine module is available
        if not license_service.has_module(ModuleCode.VULN_ENGINE):
            raise VulnerabilityServiceError(
                "Vulnerability scanning requires Pro+ license with vuln_engine module"
            )

        vuln_engine = module_loader.get_module("vuln_engine")
        if vuln_engine is None:
            raise VulnerabilityServiceError("vuln_engine module is not loaded")

        session_local = sessionmaker(
            autocommit=False, autoflush=False, bind=db_module.get_engine()
        )

        with session_local() as db:
            # Gather host information
            host = db.query(Host).filter(Host.id == host_id).first()
            if not host:
                raise VulnerabilityServiceError(f"Host not found: {host_id}")

            # Gather packages
            try:
                packages = self._gather_host_packages(db, host_id)
            except Exception as e:
                raise VulnerabilityServiceError(
                    f"Failed to gather host packages: {e}"
                ) from e

            if not packages:
                # No packages to scan
                now = datetime.now(timezone.utc).replace(tzinfo=None)
                scan = HostVulnerabilityScan(
                    host_id=host_id,
                    scanned_at=now,
                    total_packages=0,
                    vulnerable_packages=0,
                    total_vulnerabilities=0,
                    critical_count=0,
                    high_count=0,
                    medium_count=0,
                    low_count=0,
                    risk_score=0,
                    risk_level="NONE",
                    summary="No packages found to scan.",
                    scanner_version=vuln_engine.get_module_info()["version"],
                )
                db.add(scan)
                db.commit()
                db.refresh(scan)

                return {
                    "id": str(scan.id),
                    "host_id": str(host_id),
                    "scanned_at": scan.scanned_at.isoformat(),
                    "total_packages": 0,
                    "vulnerable_packages": 0,
                    "total_vulnerabilities": 0,
                    "critical_count": 0,
                    "high_count": 0,
                    "medium_count": 0,
                    "low_count": 0,
                    "risk_score": 0,
                    "risk_level": "NONE",
                    "summary": "No packages found to scan.",
                    "vulnerabilities": [],
                }

            # Get unique package managers from packages
            package_managers = list({pkg["package_manager"] for pkg in packages})

            # Get vulnerability data for those package managers
            vulnerability_data = self._get_vulnerability_data(db, package_managers)

            # Run scan through vuln_engine
            try:
                result = vuln_engine.scan_packages(packages, vulnerability_data)
            except Exception as e:
                raise VulnerabilityServiceError(f"Security scanner failed: {e}") from e

            # Generate report
            host_info = {
                "hostname": host.fqdn,
                "os_name": host.platform,
                "os_version": host.platform_version,
                "architecture": host.machine_architecture,
            }
            report = vuln_engine.generate_host_vulnerability_report(result, host_info)

            # Save to database
            now = datetime.now(timezone.utc).replace(tzinfo=None)
            scan = HostVulnerabilityScan(
                host_id=host_id,
                scanned_at=now,
                total_packages=result.get("total_packages", 0),
                vulnerable_packages=result.get("vulnerable_packages", 0),
                total_vulnerabilities=result.get("total_vulnerabilities", 0),
                critical_count=result.get("critical_count", 0),
                high_count=result.get("high_count", 0),
                medium_count=result.get("medium_count", 0),
                low_count=result.get("low_count", 0),
                risk_score=result.get("risk_score", 0),
                risk_level=report.get("risk_level", "UNKNOWN"),
                summary=result.get("summary", ""),
                recommendations=report.get("recommendations", []),
                scanner_version=result.get("engine_version", "unknown"),
            )
            db.add(scan)
            db.flush()

            # Save individual findings
            vulnerabilities = result.get("vulnerabilities", [])
            for vuln in vulnerabilities:
                # Find the vulnerability record
                vuln_record = (
                    db.query(Vulnerability)
                    .filter(Vulnerability.cve_id == vuln.get("cve_id"))
                    .first()
                )
                if vuln_record:
                    finding = HostVulnerabilityFinding(
                        scan_id=scan.id,
                        vulnerability_id=vuln_record.id,
                        package_name=vuln.get("package_name", ""),
                        installed_version=vuln.get("installed_version", ""),
                        fixed_version=vuln.get("fixed_version"),
                        severity=vuln.get("severity", "UNKNOWN"),
                        cvss_score=str(vuln.get("cvss_score", 0)),
                        remediation=vuln.get("remediation"),
                    )
                    db.add(finding)

            db.commit()
            db.refresh(scan)

            logger.info(
                "Vulnerability scan completed for host %s: total=%d, critical=%d",
                host_id,
                result.get("total_vulnerabilities", 0),
                result.get("critical_count", 0),
            )

            return {
                "id": str(scan.id),
                "host_id": str(host_id),
                "scanned_at": scan.scanned_at.isoformat(),
                "total_packages": scan.total_packages,
                "vulnerable_packages": scan.vulnerable_packages,
                "total_vulnerabilities": scan.total_vulnerabilities,
                "critical_count": scan.critical_count,
                "high_count": scan.high_count,
                "medium_count": scan.medium_count,
                "low_count": scan.low_count,
                "risk_score": scan.risk_score,
                "risk_level": scan.risk_level,
                "summary": scan.summary,
                "recommendations": scan.recommendations,
                "vulnerabilities": vulnerabilities[:50],  # Limit to top 50 in response
            }

    def get_latest_scan(self, host_id: str) -> Optional[Dict[str, Any]]:
        """
        Get the most recent vulnerability scan for a host.

        Args:
            host_id: The host ID

        Returns:
            Dictionary with scan results, or None if no scan exists
        """
        session_local = sessionmaker(
            autocommit=False, autoflush=False, bind=db_module.get_engine()
        )

        with session_local() as db:
            scan = (
                db.query(HostVulnerabilityScan)
                .filter(HostVulnerabilityScan.host_id == host_id)
                .order_by(HostVulnerabilityScan.scanned_at.desc())
                .first()
            )

            if not scan:
                return None

            # Get findings
            findings = (
                db.query(HostVulnerabilityFinding)
                .filter(HostVulnerabilityFinding.scan_id == scan.id)
                .all()
            )

            vulnerabilities = []
            for finding in findings:
                vuln = finding.vulnerability
                vulnerabilities.append(
                    {
                        "cve_id": vuln.cve_id if vuln else "UNKNOWN",
                        "package_name": finding.package_name,
                        "installed_version": finding.installed_version,
                        "fixed_version": finding.fixed_version,
                        "severity": finding.severity,
                        "cvss_score": finding.cvss_score,
                        "remediation": finding.remediation,
                        "description": vuln.description if vuln else None,
                    }
                )

            return {
                "id": str(scan.id),
                "host_id": str(scan.host_id),
                "scanned_at": scan.scanned_at.isoformat(),
                "total_packages": scan.total_packages,
                "vulnerable_packages": scan.vulnerable_packages,
                "total_vulnerabilities": scan.total_vulnerabilities,
                "critical_count": scan.critical_count,
                "high_count": scan.high_count,
                "medium_count": scan.medium_count,
                "low_count": scan.low_count,
                "risk_score": scan.risk_score,
                "risk_level": scan.risk_level,
                "summary": scan.summary,
                "recommendations": scan.recommendations,
                "vulnerabilities": vulnerabilities,
            }

    def get_scan_history(self, host_id: str, limit: int = 10) -> List[Dict[str, Any]]:
        """
        Get vulnerability scan history for a host.

        Args:
            host_id: The host ID
            limit: Maximum number of records to return

        Returns:
            List of scan results (without full vulnerability details)
        """
        session_local = sessionmaker(
            autocommit=False, autoflush=False, bind=db_module.get_engine()
        )

        with session_local() as db:
            scans = (
                db.query(HostVulnerabilityScan)
                .filter(HostVulnerabilityScan.host_id == host_id)
                .order_by(HostVulnerabilityScan.scanned_at.desc())
                .limit(limit)
                .all()
            )

            return [
                {
                    "id": str(s.id),
                    "host_id": str(s.host_id),
                    "scanned_at": s.scanned_at.isoformat(),
                    "total_packages": s.total_packages,
                    "vulnerable_packages": s.vulnerable_packages,
                    "total_vulnerabilities": s.total_vulnerabilities,
                    "critical_count": s.critical_count,
                    "high_count": s.high_count,
                    "medium_count": s.medium_count,
                    "low_count": s.low_count,
                    "risk_score": s.risk_score,
                    "risk_level": s.risk_level,
                    "summary": s.summary,
                }
                for s in scans
            ]

    def _get_scan_value(
        self, scan: Optional[HostVulnerabilityScan], attr: str, default: Any
    ) -> Any:
        """Safely get a scan attribute value with a default."""
        if scan is None:
            return default
        value = getattr(scan, attr, None)
        return value if value is not None else default

    def _build_host_vuln_data(
        self, host: Host, scan: Optional[HostVulnerabilityScan]
    ) -> Dict[str, Any]:
        """Build vulnerability data dictionary for a single host."""
        hostname = host.fqdn.split(".")[0] if host.fqdn else str(host.id)
        scanned_at = self._get_scan_value(scan, "scanned_at", None)

        return {
            "host_id": str(host.id),
            "hostname": hostname,
            "fqdn": host.fqdn or "",
            "critical_count": self._get_scan_value(scan, "critical_count", 0),
            "high_count": self._get_scan_value(scan, "high_count", 0),
            "medium_count": self._get_scan_value(scan, "medium_count", 0),
            "low_count": self._get_scan_value(scan, "low_count", 0),
            "total_vulnerabilities": self._get_scan_value(
                scan, "total_vulnerabilities", 0
            ),
            "risk_score": self._get_scan_value(scan, "risk_score", 0),
            "risk_level": self._get_scan_value(scan, "risk_level", "NONE"),
            "last_scanned_at": scanned_at.isoformat() if scanned_at else None,
        }

    def get_hosts_with_vulnerabilities(self) -> List[Dict[str, Any]]:
        """
        Get all hosts with their latest vulnerability scan results.

        Returns:
            List of hosts with vulnerability counts by severity
        """
        session_local = sessionmaker(
            autocommit=False, autoflush=False, bind=db_module.get_engine()
        )

        with session_local() as db:
            # Get all active hosts
            hosts = db.query(Host).filter(Host.active == True).all()  # noqa: E712

            result = []
            for host in hosts:
                # Get the latest vulnerability scan for this host
                scan = (
                    db.query(HostVulnerabilityScan)
                    .filter(HostVulnerabilityScan.host_id == host.id)
                    .order_by(HostVulnerabilityScan.scanned_at.desc())
                    .first()
                )

                result.append(self._build_host_vuln_data(host, scan))

            return result

    def get_enterprise_summary(self) -> Dict[str, Any]:
        """
        Get enterprise-wide vulnerability summary.

        Returns:
            Dictionary with enterprise-wide vulnerability metrics
        """
        # Check if vuln_engine module is available
        if not license_service.has_module(ModuleCode.VULN_ENGINE):
            raise VulnerabilityServiceError(
                "Vulnerability scanning requires Pro+ license with vuln_engine module"
            )

        vuln_engine = module_loader.get_module("vuln_engine")
        if vuln_engine is None:
            raise VulnerabilityServiceError("vuln_engine module is not loaded")

        session_local = sessionmaker(
            autocommit=False, autoflush=False, bind=db_module.get_engine()
        )

        with session_local() as db:
            # Get latest scan for each host
            from sqlalchemy import func

            subquery = (
                db.query(
                    HostVulnerabilityScan.host_id,
                    func.max(HostVulnerabilityScan.scanned_at).label("latest_scan"),
                )
                .group_by(HostVulnerabilityScan.host_id)
                .subquery()
            )

            latest_scans = (
                db.query(HostVulnerabilityScan)
                .join(
                    subquery,
                    (HostVulnerabilityScan.host_id == subquery.c.host_id)
                    & (HostVulnerabilityScan.scanned_at == subquery.c.latest_scan),
                )
                .all()
            )

            if not latest_scans:
                return {
                    "total_hosts": 0,
                    "hosts_by_risk": {
                        "critical": 0,
                        "high": 0,
                        "medium": 0,
                        "low": 0,
                        "clean": 0,
                    },
                    "total_vulnerabilities": {
                        "critical": 0,
                        "high": 0,
                        "medium": 0,
                        "low": 0,
                        "total": 0,
                    },
                    "enterprise_risk_score": 0,
                    "enterprise_risk_level": "NONE",
                }

            # Build host reports for the vuln_engine
            host_reports = []
            for scan in latest_scans:
                host_reports.append(
                    {
                        "risk_level": scan.risk_level,
                        "risk_score": scan.risk_score,
                        "statistics": {
                            "total_packages": scan.total_packages,
                            "vulnerable_packages": scan.vulnerable_packages,
                            "total_vulnerabilities": scan.total_vulnerabilities,
                            "by_severity": {
                                "critical": scan.critical_count,
                                "high": scan.high_count,
                                "medium": scan.medium_count,
                                "low": scan.low_count,
                            },
                        },
                        "all_vulnerabilities": [],  # Not needed for summary
                    }
                )

            # Use vuln_engine to generate enterprise summary
            summary = vuln_engine.generate_enterprise_summary(host_reports)

            return summary


# Global vulnerability service instance
vulnerability_service = VulnerabilityService()
