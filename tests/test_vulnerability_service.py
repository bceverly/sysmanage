"""
Tests for backend/vulnerability/vulnerability_service.py module.
Tests the VulnerabilityService wrapper for Pro+ vulnerability scanning.
"""

from unittest.mock import MagicMock, patch

import pytest

from backend.vulnerability.vulnerability_service import (
    VulnerabilityService,
    VulnerabilityServiceError,
)


class TestVulnerabilityServiceError:
    """Tests for VulnerabilityServiceError exception."""

    def test_error_message(self):
        """Test that error message is preserved."""
        error = VulnerabilityServiceError("Test error message")
        assert str(error) == "Test error message"

    def test_error_inheritance(self):
        """Test that it inherits from Exception."""
        error = VulnerabilityServiceError("Test")
        assert isinstance(error, Exception)


class TestVulnerabilityServiceInit:
    """Tests for VulnerabilityService initialization."""

    def test_vulnerability_service_instance(self):
        """Test that vulnerability_service global instance exists."""
        from backend.vulnerability.vulnerability_service import vulnerability_service

        assert vulnerability_service is not None
        assert isinstance(vulnerability_service, VulnerabilityService)


class TestVulnerabilityServiceGetModule:
    """Tests for VulnerabilityService._get_module method."""

    @patch("backend.vulnerability.vulnerability_service.module_loader")
    @patch("backend.vulnerability.vulnerability_service.license_service")
    def test_get_module_no_license(self, mock_license_service, mock_module_loader):
        """Test _get_module when license is not available."""
        mock_license_service.has_module.return_value = False

        service = VulnerabilityService()
        with pytest.raises(VulnerabilityServiceError) as exc_info:
            service._get_module()

        assert "Pro+ license" in str(exc_info.value)

    @patch("backend.vulnerability.vulnerability_service.module_loader")
    @patch("backend.vulnerability.vulnerability_service.license_service")
    def test_get_module_not_loaded(self, mock_license_service, mock_module_loader):
        """Test _get_module when module is licensed but not loaded."""
        mock_license_service.has_module.return_value = True
        mock_module_loader.get_module.return_value = None

        service = VulnerabilityService()
        with pytest.raises(VulnerabilityServiceError) as exc_info:
            service._get_module()

        assert "not loaded" in str(exc_info.value)

    @patch("backend.vulnerability.vulnerability_service.module_loader")
    @patch("backend.vulnerability.vulnerability_service.license_service")
    def test_get_module_success(self, mock_license_service, mock_module_loader):
        """Test _get_module when module is available."""
        mock_license_service.has_module.return_value = True
        mock_vuln_engine = MagicMock()
        mock_module_loader.get_module.return_value = mock_vuln_engine

        service = VulnerabilityService()
        result = service._get_module()

        assert result == mock_vuln_engine


class TestVulnerabilityServiceGetDbSession:
    """Tests for VulnerabilityService._get_db_session method."""

    @patch("backend.vulnerability.vulnerability_service.db_module")
    def test_get_db_session(self, mock_db_module):
        """Test _get_db_session returns a session."""
        mock_engine = MagicMock()
        mock_db_module.get_engine.return_value = mock_engine

        service = VulnerabilityService()
        session = service._get_db_session()

        # Should return a session object
        assert session is not None


class TestVulnerabilityServiceScanHost:
    """Tests for VulnerabilityService.scan_host method."""

    @patch("backend.vulnerability.vulnerability_service.db_module")
    @patch("backend.vulnerability.vulnerability_service.module_loader")
    @patch("backend.vulnerability.vulnerability_service.license_service")
    def test_scan_host_success(
        self, mock_license_service, mock_module_loader, mock_db_module
    ):
        """Test scan_host with successful scan."""
        mock_license_service.has_module.return_value = True

        mock_vuln_service = MagicMock()
        mock_vuln_service.scan_host.return_value = {
            "host_id": "test-host",
            "vulnerabilities_found": 5,
        }
        mock_vuln_engine = MagicMock()
        mock_vuln_engine._vulnerability_service = mock_vuln_service
        mock_module_loader.get_module.return_value = mock_vuln_engine

        mock_engine = MagicMock()
        mock_db_module.get_engine.return_value = mock_engine

        service = VulnerabilityService()
        result = service.scan_host("test-host-id")

        assert result["host_id"] == "test-host"
        assert result["vulnerabilities_found"] == 5

    @patch("backend.vulnerability.vulnerability_service.license_service")
    def test_scan_host_no_license(self, mock_license_service):
        """Test scan_host when no license available."""
        mock_license_service.has_module.return_value = False

        service = VulnerabilityService()
        with pytest.raises(VulnerabilityServiceError):
            service.scan_host("test-host-id")


class TestVulnerabilityServiceGetLatestScan:
    """Tests for VulnerabilityService.get_latest_scan method."""

    @patch("backend.vulnerability.vulnerability_service.db_module")
    @patch("backend.vulnerability.vulnerability_service.module_loader")
    @patch("backend.vulnerability.vulnerability_service.license_service")
    def test_get_latest_scan_success(
        self, mock_license_service, mock_module_loader, mock_db_module
    ):
        """Test get_latest_scan with existing scan."""
        mock_license_service.has_module.return_value = True

        mock_vuln_service = MagicMock()
        mock_vuln_service.get_latest_scan.return_value = {
            "host_id": "test-host",
            "timestamp": "2024-01-01T00:00:00Z",
        }
        mock_vuln_engine = MagicMock()
        mock_vuln_engine._vulnerability_service = mock_vuln_service
        mock_module_loader.get_module.return_value = mock_vuln_engine

        mock_engine = MagicMock()
        mock_db_module.get_engine.return_value = mock_engine

        service = VulnerabilityService()
        result = service.get_latest_scan("test-host-id")

        assert result["host_id"] == "test-host"

    @patch("backend.vulnerability.vulnerability_service.db_module")
    @patch("backend.vulnerability.vulnerability_service.module_loader")
    @patch("backend.vulnerability.vulnerability_service.license_service")
    def test_get_latest_scan_none(
        self, mock_license_service, mock_module_loader, mock_db_module
    ):
        """Test get_latest_scan when no scan exists."""
        mock_license_service.has_module.return_value = True

        mock_vuln_service = MagicMock()
        mock_vuln_service.get_latest_scan.return_value = None
        mock_vuln_engine = MagicMock()
        mock_vuln_engine._vulnerability_service = mock_vuln_service
        mock_module_loader.get_module.return_value = mock_vuln_engine

        mock_engine = MagicMock()
        mock_db_module.get_engine.return_value = mock_engine

        service = VulnerabilityService()
        result = service.get_latest_scan("test-host-id")

        assert result is None


class TestVulnerabilityServiceGetScanHistory:
    """Tests for VulnerabilityService.get_scan_history method."""

    @patch("backend.vulnerability.vulnerability_service.db_module")
    @patch("backend.vulnerability.vulnerability_service.module_loader")
    @patch("backend.vulnerability.vulnerability_service.license_service")
    def test_get_scan_history_success(
        self, mock_license_service, mock_module_loader, mock_db_module
    ):
        """Test get_scan_history with existing history."""
        mock_license_service.has_module.return_value = True

        mock_vuln_service = MagicMock()
        mock_vuln_service.get_scan_history.return_value = [
            {"timestamp": "2024-01-02T00:00:00Z", "count": 10},
            {"timestamp": "2024-01-01T00:00:00Z", "count": 8},
        ]
        mock_vuln_engine = MagicMock()
        mock_vuln_engine._vulnerability_service = mock_vuln_service
        mock_module_loader.get_module.return_value = mock_vuln_engine

        mock_engine = MagicMock()
        mock_db_module.get_engine.return_value = mock_engine

        service = VulnerabilityService()
        result = service.get_scan_history("test-host-id", limit=10)

        assert len(result) == 2
        assert result[0]["count"] == 10

    @patch("backend.vulnerability.vulnerability_service.db_module")
    @patch("backend.vulnerability.vulnerability_service.module_loader")
    @patch("backend.vulnerability.vulnerability_service.license_service")
    def test_get_scan_history_empty(
        self, mock_license_service, mock_module_loader, mock_db_module
    ):
        """Test get_scan_history with empty history."""
        mock_license_service.has_module.return_value = True

        mock_vuln_service = MagicMock()
        mock_vuln_service.get_scan_history.return_value = []
        mock_vuln_engine = MagicMock()
        mock_vuln_engine._vulnerability_service = mock_vuln_service
        mock_module_loader.get_module.return_value = mock_vuln_engine

        mock_engine = MagicMock()
        mock_db_module.get_engine.return_value = mock_engine

        service = VulnerabilityService()
        result = service.get_scan_history("test-host-id")

        assert result == []


class TestVulnerabilityServiceGetHostsWithVulnerabilities:
    """Tests for VulnerabilityService.get_hosts_with_vulnerabilities method."""

    @patch("backend.vulnerability.vulnerability_service.db_module")
    @patch("backend.vulnerability.vulnerability_service.module_loader")
    @patch("backend.vulnerability.vulnerability_service.license_service")
    def test_get_hosts_with_vulnerabilities_success(
        self, mock_license_service, mock_module_loader, mock_db_module
    ):
        """Test get_hosts_with_vulnerabilities with results."""
        mock_license_service.has_module.return_value = True

        mock_vuln_service = MagicMock()
        mock_vuln_service.get_hosts_with_vulnerabilities.return_value = [
            {"host_id": "host1", "critical": 2, "high": 5},
            {"host_id": "host2", "critical": 0, "high": 3},
        ]
        mock_vuln_engine = MagicMock()
        mock_vuln_engine._vulnerability_service = mock_vuln_service
        mock_module_loader.get_module.return_value = mock_vuln_engine

        mock_engine = MagicMock()
        mock_db_module.get_engine.return_value = mock_engine

        service = VulnerabilityService()
        result = service.get_hosts_with_vulnerabilities()

        assert len(result) == 2
        assert result[0]["critical"] == 2


class TestVulnerabilityServiceGetEnterpriseSummary:
    """Tests for VulnerabilityService.get_enterprise_summary method."""

    @patch("backend.vulnerability.vulnerability_service.db_module")
    @patch("backend.vulnerability.vulnerability_service.module_loader")
    @patch("backend.vulnerability.vulnerability_service.license_service")
    def test_get_enterprise_summary_success(
        self, mock_license_service, mock_module_loader, mock_db_module
    ):
        """Test get_enterprise_summary with results."""
        mock_license_service.has_module.return_value = True

        mock_vuln_service = MagicMock()
        mock_vuln_service.get_enterprise_summary_data.return_value = {
            "total_hosts": 50,
            "hosts_with_critical": 5,
            "total_vulnerabilities": 150,
        }
        mock_vuln_engine = MagicMock()
        mock_vuln_engine._vulnerability_service = mock_vuln_service
        mock_module_loader.get_module.return_value = mock_vuln_engine

        mock_engine = MagicMock()
        mock_db_module.get_engine.return_value = mock_engine

        service = VulnerabilityService()
        result = service.get_enterprise_summary()

        assert result["total_hosts"] == 50
        assert result["total_vulnerabilities"] == 150
