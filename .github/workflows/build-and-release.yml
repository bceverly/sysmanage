name: Build and Release

on:
  # Trigger on version tags (e.g., v1.0.0, v2.1.3, v0.9.0.3)
  push:
    tags:
      - 'v*.*.*'
      - 'v*.*.*.*'

permissions:
  contents: write  # Needed for creating releases and pushing to repos

jobs:
  # Wait for CI tests to pass before building
  wait-for-tests:
    name: Wait for CI Tests
    runs-on: ubuntu-latest
    steps:
      - name: Wait for Backend Tests (Python 3.10)
        uses: lewagon/wait-on-check-action@v1.4.1
        with:
          ref: ${{ github.sha }}
          check-name: 'Backend Tests (Python 3.10)'
          repo-token: ${{ secrets.GITHUB_TOKEN }}
          wait-interval: 30

      - name: Wait for Backend Tests (Linux + PostgreSQL)
        uses: lewagon/wait-on-check-action@v1.4.1
        with:
          ref: ${{ github.sha }}
          check-name: 'Backend Tests (Linux + PostgreSQL)'
          repo-token: ${{ secrets.GITHUB_TOKEN }}
          wait-interval: 30

      - name: Wait for Frontend Tests (ubuntu-latest)
        uses: lewagon/wait-on-check-action@v1.4.1
        with:
          ref: ${{ github.sha }}
          check-name: 'Frontend Tests (ubuntu-latest)'
          repo-token: ${{ secrets.GITHUB_TOKEN }}
          wait-interval: 30

      - name: Wait for Frontend Tests (windows-latest)
        uses: lewagon/wait-on-check-action@v1.4.1
        with:
          ref: ${{ github.sha }}
          check-name: 'Frontend Tests (windows-latest)'
          repo-token: ${{ secrets.GITHUB_TOKEN }}
          wait-interval: 30

      - name: Wait for Frontend Tests (macos-latest)
        uses: lewagon/wait-on-check-action@v1.4.1
        with:
          ref: ${{ github.sha }}
          check-name: 'Frontend Tests (macos-latest)'
          repo-token: ${{ secrets.GITHUB_TOKEN }}
          wait-interval: 30

  # Ubuntu/Debian .deb Package Build
  build-ubuntu:
    name: Build .deb Package
    runs-on: ubuntu-22.04
    needs: wait-for-tests

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Set up Node.js
        uses: actions/setup-node@v6
        with:
          node-version: '20'

      - name: Set up Python 3.12
        uses: actions/setup-python@v6
        with:
          python-version: '3.12'

      - name: Determine version
        id: version
        run: |
          # Extract version from tag (remove 'v' prefix)
          VERSION="${GITHUB_REF#refs/tags/v}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Building version: $VERSION"

      - name: Install build dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            debhelper \
            dh-python \
            python3-all \
            python3-setuptools \
            python3-pip \
            build-essential \
            devscripts \
            lintian

      - name: Install frontend dependencies
        run: |
          cd frontend
          npm install

      - name: Install SBOM generation tools
        run: |
          # Install cyclonedx-bom for Python
          python3 -m pip install cyclonedx-bom

          # Install cyclonedx-npm globally for Node.js
          sudo npm install -g @cyclonedx/cyclonedx-npm

          # Verify installations
          python3 -c "import cyclonedx_py; print('âœ“ cyclonedx-bom installed')"
          cyclonedx-npm --version

      - name: Build frontend
        run: |
          cd frontend
          npm run build

      - name: Update changelog with version
        env:
          VERSION: ${{ steps.version.outputs.version }}
        run: |
          DATE=$(date -R)

          # Update changelog with actual version and date
          sed -i "s/0\.1\.0-1/${VERSION}-1/g" installer/ubuntu/debian/changelog
          sed -i "s/Mon, 14 Oct 2025 00:00:00 -0400/$DATE/g" installer/ubuntu/debian/changelog

          echo "Updated changelog:"
          head -5 installer/ubuntu/debian/changelog

      - name: Build package
        env:
          VERSION: ${{ steps.version.outputs.version }}
        run: |
          echo "Building version: ${VERSION}"
          make installer-deb

      - name: Run lintian on package
        run: |
          lintian --no-tag-display-limit installer/dist/sysmanage_*.deb || true

      - name: Generate package information
        id: package_info
        env:
          VERSION: ${{ steps.version.outputs.version }}
        run: |
          DEB_FILE="installer/dist/sysmanage_${VERSION}-1_all.deb"
          echo "deb_file=$DEB_FILE" >> $GITHUB_OUTPUT

          # Get package info
          dpkg-deb --info "$DEB_FILE"
          dpkg-deb --contents "$DEB_FILE" | head -20

          # Generate SHA256 checksum
          cd installer/dist
          sha256sum "sysmanage_${VERSION}-1_all.deb" > "sysmanage_${VERSION}-1_all.deb.sha256"

          echo "Package built: $DEB_FILE"
          echo "Size: $(du -h $DEB_FILE | cut -f1)"

      - name: Upload .deb as artifact
        uses: actions/upload-artifact@v5
        with:
          name: sysmanage-server-deb
          path: |
            installer/dist/sysmanage_*.deb
            installer/dist/sysmanage_*.deb.sha256

      - name: Upload SBOM files as artifact
        uses: actions/upload-artifact@v5
        with:
          name: sysmanage-sbom
          path: |
            sbom/*.json

  # OpenBSD Port Tarball Build
  build-openbsd-port:
    name: Build OpenBSD Port Tarball
    runs-on: ubuntu-22.04
    needs: wait-for-tests

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Set up Node.js
        uses: actions/setup-node@v6
        with:
          node-version: '20'

      - name: Set up Python 3.12
        uses: actions/setup-python@v6
        with:
          python-version: '3.12'

      - name: Determine version
        id: version
        run: |
          # Extract version from tag (remove 'v' prefix)
          VERSION="${GITHUB_REF#refs/tags/v}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Building OpenBSD port for version: $VERSION"

      - name: Install frontend dependencies
        run: |
          cd frontend
          npm install

      - name: Install SBOM generation tools
        run: |
          # Install cyclonedx-bom for Python
          python3 -m pip install cyclonedx-bom

          # Install cyclonedx-npm globally for Node.js
          sudo npm install -g @cyclonedx/cyclonedx-npm

          # Verify installations
          python3 -c "import cyclonedx_py; print('[OK] cyclonedx-bom installed')"
          cyclonedx-npm --version

      - name: Build frontend
        run: |
          cd frontend
          npm run build

      - name: Generate SBOM files
        run: |
          echo "Generating SBOM files..."
          make sbom

      - name: Build OpenBSD port tarball
        env:
          VERSION: ${{ steps.version.outputs.version }}
        run: |
          echo "Building OpenBSD port tarball for version: ${VERSION}"
          make installer-openbsd

      - name: Generate SHA256 checksum
        env:
          VERSION: ${{ steps.version.outputs.version }}
        run: |
          cd installer/dist
          sha256sum "sysmanage-openbsd-port-${VERSION}.tar.gz" > "sysmanage-openbsd-port-${VERSION}.tar.gz.sha256"
          echo "Checksum generated:"
          cat "sysmanage-openbsd-port-${VERSION}.tar.gz.sha256"

      - name: Upload OpenBSD port tarball as artifact
        uses: actions/upload-artifact@v5
        with:
          name: sysmanage-openbsd-port
          path: |
            installer/dist/sysmanage-openbsd-port-*.tar.gz
            installer/dist/sysmanage-openbsd-port-*.tar.gz.sha256

  # CentOS/RHEL/Fedora RPM Build
  build-centos-rpm:
    name: Build CentOS/RHEL RPM
    runs-on: ubuntu-22.04
    needs: wait-for-tests

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Set up Node.js
        uses: actions/setup-node@v6
        with:
          node-version: '20'

      - name: Set up Python 3.12
        uses: actions/setup-python@v6
        with:
          python-version: '3.12'

      - name: Determine version
        id: version
        run: |
          # Extract version from tag (remove 'v' prefix)
          VERSION="${GITHUB_REF#refs/tags/v}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Building CentOS RPM for version: $VERSION"

      - name: Install RPM build tools
        run: |
          sudo apt-get update
          sudo apt-get install -y rpm

      - name: Install frontend dependencies
        run: |
          cd frontend
          npm install

      - name: Install SBOM generation tools
        run: |
          # Install cyclonedx-bom for Python
          python3 -m pip install cyclonedx-bom

          # Install cyclonedx-npm globally for Node.js
          sudo npm install -g @cyclonedx/cyclonedx-npm

          # Verify installations
          python3 -c "import cyclonedx_py; print('[OK] cyclonedx-bom installed')"
          cyclonedx-npm --version

      - name: Build frontend
        run: |
          cd frontend
          npm run build

      - name: Build CentOS RPM package
        env:
          VERSION: ${{ steps.version.outputs.version }}
        run: |
          echo "Building CentOS RPM for version: ${VERSION}"
          make installer-rpm-centos

      - name: Upload CentOS RPM as artifact
        uses: actions/upload-artifact@v5
        with:
          name: sysmanage-centos-rpm
          path: |
            installer/dist/sysmanage-*.rpm
            installer/dist/sysmanage-*.rpm.sha256

  # OpenSUSE/SLES RPM Build
  build-opensuse-rpm:
    name: Build OpenSUSE/SLES RPM
    runs-on: ubuntu-22.04
    needs: wait-for-tests

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Set up Node.js
        uses: actions/setup-node@v6
        with:
          node-version: '20'

      - name: Set up Python 3.12
        uses: actions/setup-python@v6
        with:
          python-version: '3.12'

      - name: Determine version
        id: version
        run: |
          # Extract version from tag (remove 'v' prefix)
          VERSION="${GITHUB_REF#refs/tags/v}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Building OpenSUSE RPM for version: $VERSION"

      - name: Install RPM build tools
        run: |
          sudo apt-get update
          sudo apt-get install -y rpm

      - name: Install frontend dependencies
        run: |
          cd frontend
          npm install

      - name: Install SBOM generation tools
        run: |
          # Install cyclonedx-bom for Python
          python3 -m pip install cyclonedx-bom

          # Install cyclonedx-npm globally for Node.js
          sudo npm install -g @cyclonedx/cyclonedx-npm

          # Verify installations
          python3 -c "import cyclonedx_py; print('[OK] cyclonedx-bom installed')"
          cyclonedx-npm --version

      - name: Build frontend
        run: |
          cd frontend
          npm run build

      - name: Build OpenSUSE RPM package
        env:
          VERSION: ${{ steps.version.outputs.version }}
        run: |
          echo "Building OpenSUSE RPM for version: ${VERSION}"
          make installer-rpm-opensuse

      - name: Upload OpenSUSE RPM as artifact
        uses: actions/upload-artifact@v5
        with:
          name: sysmanage-opensuse-rpm
          path: |
            installer/dist/sysmanage-*.rpm
            installer/dist/sysmanage-*.rpm.sha256

  # FreeBSD Package Build
  build-freebsd-pkg:
    name: Build FreeBSD Package
    runs-on: ubuntu-22.04
    needs: wait-for-tests

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Set up Node.js
        uses: actions/setup-node@v6
        with:
          node-version: '20'

      - name: Set up Python 3.12
        uses: actions/setup-python@v6
        with:
          python-version: '3.12'

      - name: Determine version
        id: version
        run: |
          # Extract version from tag (remove 'v' prefix)
          VERSION="${GITHUB_REF#refs/tags/v}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Building FreeBSD package for version: $VERSION"

      - name: Install FreeBSD packaging tools
        run: |
          sudo apt-get update
          # Install libarchive-tools for bsdtar which is compatible with FreeBSD pkg format
          sudo apt-get install -y libarchive-tools

      - name: Install frontend dependencies
        run: |
          cd frontend
          npm install

      - name: Install SBOM generation tools
        run: |
          # Install cyclonedx-bom for Python
          python3 -m pip install cyclonedx-bom

          # Install cyclonedx-npm globally for Node.js
          sudo npm install -g @cyclonedx/cyclonedx-npm

          # Verify installations
          python3 -c "import cyclonedx_py; print('[OK] cyclonedx-bom installed')"
          cyclonedx-npm --version

      - name: Build frontend
        run: |
          cd frontend
          npm run build

      - name: Build FreeBSD package
        env:
          VERSION: ${{ steps.version.outputs.version }}
        run: |
          echo "Building FreeBSD package for version: ${VERSION}"
          make installer-freebsd

      - name: Upload FreeBSD package as artifact
        uses: actions/upload-artifact@v5
        with:
          name: sysmanage-freebsd-pkg
          path: |
            installer/dist/sysmanage-*.pkg
            installer/dist/sysmanage-*.pkg.sha256

  build-macos-pkg:
    name: Build macOS Package
    runs-on: macos-14
    needs: wait-for-tests

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Set up Node.js
        uses: actions/setup-node@v6
        with:
          node-version: '20'

      - name: Set up Python 3.12
        uses: actions/setup-python@v6
        with:
          python-version: '3.12'

      - name: Determine version
        id: version
        run: |
          # Extract version from tag (remove 'v' prefix)
          VERSION="${GITHUB_REF#refs/tags/v}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Building macOS package for version: $VERSION"

      - name: Install Xcode Command Line Tools
        run: |
          # Ensure Xcode command line tools are installed
          xcode-select -p || xcode-select --install

      - name: Install frontend dependencies
        run: |
          cd frontend
          npm install

      - name: Install SBOM generation tools
        run: |
          # Install cyclonedx-bom for Python
          python3 -m pip install cyclonedx-bom

          # Install cyclonedx-npm globally for Node.js
          npm install -g @cyclonedx/cyclonedx-npm

          # Verify installations
          python3 -c "import cyclonedx_py; print('[OK] cyclonedx-bom installed')"
          cyclonedx-npm --version

      - name: Build frontend
        run: |
          cd frontend
          npm run build

      - name: Build macOS package
        env:
          VERSION: ${{ steps.version.outputs.version }}
        run: |
          echo "Building macOS package for version: ${VERSION}"
          make installer-macos

      - name: Upload macOS package as artifact
        uses: actions/upload-artifact@v5
        with:
          name: sysmanage-macos-pkg
          path: |
            installer/dist/sysmanage-*-macos.pkg
            installer/dist/sysmanage-*-macos.pkg.sha256

  build-netbsd-pkg:
    name: Build NetBSD Package
    runs-on: ubuntu-latest
    needs: wait-for-tests

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Set up Node.js
        uses: actions/setup-node@v6
        with:
          node-version: '20'

      - name: Set up Python 3.12
        uses: actions/setup-python@v6
        with:
          python-version: '3.12'

      - name: Determine version
        id: version
        run: |
          # Extract version from tag (remove 'v' prefix)
          VERSION="${GITHUB_REF#refs/tags/v}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Building NetBSD package for version: $VERSION"

      - name: Install NetBSD package tools
        run: |
          # Install pkg_create and related tools
          sudo apt-get update
          sudo apt-get install -y pkg-config

      - name: Install frontend dependencies
        run: |
          cd frontend
          npm install

      - name: Install SBOM generation tools
        run: |
          # Install cyclonedx-bom for Python
          python3 -m pip install cyclonedx-bom

          # Install cyclonedx-npm globally for Node.js
          npm install -g @cyclonedx/cyclonedx-npm

          # Verify installations
          python3 -c "import cyclonedx_py; print('[OK] cyclonedx-bom installed')"
          cyclonedx-npm --version

      - name: Build frontend
        run: |
          cd frontend
          npm run build

      - name: Build NetBSD package
        env:
          VERSION: ${{ steps.version.outputs.version }}
        run: |
          echo "Building NetBSD package for version: ${VERSION}"
          make installer-netbsd

      - name: Upload NetBSD package as artifact
        uses: actions/upload-artifact@v5
        with:
          name: sysmanage-netbsd-pkg
          path: |
            installer/dist/sysmanage-*-netbsd.tgz
            installer/dist/sysmanage-*-netbsd.tgz.sha256

  build-windows-msi-x64:
    name: Build Windows MSI (x64)
    runs-on: windows-latest
    needs: wait-for-tests

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Set up Node.js
        uses: actions/setup-node@v6
        with:
          node-version: '20'

      - name: Set up Python 3.12
        uses: actions/setup-python@v6
        with:
          python-version: '3.12'

      - name: Determine version
        id: version
        shell: bash
        run: |
          # Extract version from tag (remove 'v' prefix)
          VERSION="${GITHUB_REF#refs/tags/v}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Building Windows MSI (x64) for version: $VERSION"

      - name: Install WiX Toolset
        run: |
          dotnet tool install --global wix
          wix --version

      - name: Install frontend dependencies
        run: |
          cd frontend
          npm install

      - name: Install SBOM generation tools
        run: |
          # Install cyclonedx-bom for Python
          python -m pip install cyclonedx-bom

          # Install cyclonedx-npm globally for Node.js
          npm install -g @cyclonedx/cyclonedx-npm

          # Verify installations
          python -c "import cyclonedx_py; print('[OK] cyclonedx-bom installed')"
          cyclonedx-npm --version

      - name: Build frontend
        run: |
          cd frontend
          npm run build

      - name: Build Windows MSI (x64)
        env:
          VERSION: ${{ steps.version.outputs.version }}
        run: |
          echo "Building Windows MSI (x64) for version: $Env:VERSION"
          powershell -ExecutionPolicy Bypass -File installer\windows\build-msi.ps1 -Architecture x64

      - name: Upload Windows MSI (x64) as artifact
        uses: actions/upload-artifact@v5
        with:
          name: sysmanage-windows-msi-x64
          path: |
            installer/dist/sysmanage-*-windows-x64.msi
            installer/dist/sysmanage-*-windows-x64.msi.sha256

  build-windows-msi-arm64:
    name: Build Windows MSI (ARM64)
    runs-on: windows-latest
    needs: wait-for-tests

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Set up Node.js
        uses: actions/setup-node@v6
        with:
          node-version: '20'

      - name: Set up Python 3.12
        uses: actions/setup-python@v6
        with:
          python-version: '3.12'

      - name: Determine version
        id: version
        shell: bash
        run: |
          # Extract version from tag (remove 'v' prefix)
          VERSION="${GITHUB_REF#refs/tags/v}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Building Windows MSI (ARM64) for version: $VERSION"

      - name: Install WiX Toolset
        run: |
          dotnet tool install --global wix
          wix --version

      - name: Install frontend dependencies
        run: |
          cd frontend
          npm install

      - name: Install SBOM generation tools
        run: |
          # Install cyclonedx-bom for Python
          python -m pip install cyclonedx-bom

          # Install cyclonedx-npm globally for Node.js
          npm install -g @cyclonedx/cyclonedx-npm

          # Verify installations
          python -c "import cyclonedx_py; print('[OK] cyclonedx-bom installed')"
          cyclonedx-npm --version

      - name: Build frontend
        run: |
          cd frontend
          npm run build

      - name: Build Windows MSI (ARM64)
        env:
          VERSION: ${{ steps.version.outputs.version }}
        run: |
          echo "Building Windows MSI (ARM64) for version: $Env:VERSION"
          powershell -ExecutionPolicy Bypass -File installer\windows\build-msi.ps1 -Architecture arm64

      - name: Upload Windows MSI (ARM64) as artifact
        uses: actions/upload-artifact@v5
        with:
          name: sysmanage-windows-msi-arm64
          path: |
            installer/dist/sysmanage-*-windows-arm64.msi
            installer/dist/sysmanage-*-windows-arm64.msi.sha256

  # Alpine Linux APK Package Build
  build-alpine:
    name: Build Alpine ${{ matrix.alpine-version }} Package
    runs-on: ubuntu-latest
    needs: wait-for-tests

    strategy:
      fail-fast: false
      matrix:
        alpine-version: ['3.19', '3.20', '3.21']

    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Set up Python 3.12
        uses: actions/setup-python@v6
        with:
          python-version: '3.12'

      - name: Determine version
        id: version
        run: |
          # Extract version from tag (remove 'v' prefix)
          VERSION="${GITHUB_REF#refs/tags/v}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Building Alpine ${{ matrix.alpine-version }} package for version: $VERSION"

      - name: Set up Alpine container
        run: |
          docker pull alpine:${{ matrix.alpine-version }}

      - name: Build package in Alpine container
        env:
          ALPINE_VERSION: ${{ matrix.alpine-version }}
          VERSION: ${{ steps.version.outputs.version }}
        run: |
          cat > build-apk.sh << 'BUILDSCRIPT'
          #!/bin/sh
          set -ex

          # Get Alpine version for repository URLs
          ALPINE_VER=$(cat /etc/alpine-release | cut -d. -f1,2)
          echo "Building on Alpine $ALPINE_VER"

          # Enable community repository (required for Python packages)
          echo "https://dl-cdn.alpinelinux.org/alpine/v${ALPINE_VER}/main" > /etc/apk/repositories
          echo "https://dl-cdn.alpinelinux.org/alpine/v${ALPINE_VER}/community" >> /etc/apk/repositories
          cat /etc/apk/repositories

          # Update package index
          apk update

          # Install build dependencies
          apk add --no-cache \
            alpine-sdk \
            sudo \
            python3 \
            py3-pip \
            nodejs \
            npm

          # Set up abuild user (required for building packages)
          adduser -D builder
          addgroup builder abuild
          echo "builder ALL=(ALL) NOPASSWD: ALL" >> /etc/sudoers

          # Create build directory structure
          mkdir -p /home/builder/packages
          mkdir -p /home/builder/aports/sysutils/sysmanage

          # Copy installer files
          cp /workspace/installer/alpine/APKBUILD /home/builder/aports/sysutils/sysmanage/
          cp /workspace/installer/alpine/sysmanage.initd /home/builder/aports/sysutils/sysmanage/
          cp /workspace/installer/alpine/sysmanage.confd /home/builder/aports/sysutils/sysmanage/
          cp /workspace/installer/alpine/sysmanage.post-install /home/builder/aports/sysutils/sysmanage/
          cp /workspace/installer/alpine/sysmanage-nginx.conf /home/builder/aports/sysutils/sysmanage/

          # Update version in APKBUILD
          cd /home/builder/aports/sysutils/sysmanage
          sed -i "s/^pkgver=.*/pkgver=$VERSION/" APKBUILD

          # Fix ownership
          chown -R builder:builder /home/builder

          # Generate signing key (for local builds)
          sudo -u builder abuild-keygen -a -i -n

          # Download source and generate checksums
          sudo -u builder abuild checksum

          # Build the package
          sudo -u builder abuild -r

          # Find and copy the built package
          find /home/builder/packages -name "*.apk" -type f
          cp /home/builder/packages/sysutils/$(uname -m)/*.apk /workspace/ || \
            cp /home/builder/packages/*/$(uname -m)/*.apk /workspace/ || \
            find /home/builder/packages -name "*.apk" -exec cp {} /workspace/ \;

          echo "Build complete!"
          BUILDSCRIPT

          chmod +x build-apk.sh

          docker run --rm \
            -v "${{ github.workspace }}:/workspace" \
            -e VERSION="${VERSION}" \
            alpine:${{ matrix.alpine-version }} \
            /workspace/build-apk.sh

      - name: Rename package with Alpine version
        env:
          VERSION: ${{ steps.version.outputs.version }}
          ALPINE_VERSION: ${{ matrix.alpine-version }}
        run: |
          ALPINE_NODOT=$(echo "$ALPINE_VERSION" | tr -d '.')

          for pkg in sysmanage-*.apk; do
            if [ -f "$pkg" ]; then
              newname="sysmanage-${VERSION}-alpine${ALPINE_NODOT}.apk"
              mv "$pkg" "$newname"
              echo "Renamed $pkg to $newname"
            fi
          done

          ls -la *.apk 2>/dev/null || echo "No packages found"

      - name: Generate SHA256 checksum
        env:
          VERSION: ${{ steps.version.outputs.version }}
          ALPINE_VERSION: ${{ matrix.alpine-version }}
        run: |
          ALPINE_NODOT=$(echo "$ALPINE_VERSION" | tr -d '.')
          PKG_FILE="sysmanage-${VERSION}-alpine${ALPINE_NODOT}.apk"
          sha256sum "$PKG_FILE" > "${PKG_FILE}.sha256"
          echo "Checksum:"
          cat "${PKG_FILE}.sha256"

      - name: Generate Alpine SBOM
        env:
          VERSION: ${{ steps.version.outputs.version }}
          ALPINE_VERSION: ${{ matrix.alpine-version }}
        run: |
          # Install cyclonedx for Python SBOM generation
          pip3 install cyclonedx-bom

          # Generate SBOM for Python dependencies
          mkdir -p sbom
          cd ${{ github.workspace }}

          # Generate Python backend SBOM
          if [ -f "requirements.txt" ]; then
            python3 -m cyclonedx_py requirements -i requirements.txt -o sbom/alpine-${{ matrix.alpine-version }}-backend-sbom.json --format json || true
          fi

          echo "SBOM files generated:"
          ls -la sbom/ 2>/dev/null || echo "No SBOM files found"

      - name: Upload Alpine ${{ matrix.alpine-version }} package
        uses: actions/upload-artifact@v5
        with:
          name: sysmanage-alpine-${{ matrix.alpine-version }}
          path: |
            sysmanage-*.apk
            sysmanage-*.apk.sha256
          if-no-files-found: error

      - name: Upload Alpine SBOM
        uses: actions/upload-artifact@v5
        with:
          name: sysmanage-alpine-sbom-${{ matrix.alpine-version }}
          path: sbom/
          if-no-files-found: warn

  # Consolidated Release - Push to sysmanage-docs and create GitHub release
  release:
    name: Create Release and Push to Docs
    runs-on: ubuntu-latest
    needs: [build-ubuntu, build-openbsd-port, build-centos-rpm, build-opensuse-rpm, build-freebsd-pkg, build-macos-pkg, build-netbsd-pkg, build-windows-msi-x64, build-windows-msi-arm64, build-alpine]

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Determine version
        id: version
        run: |
          # Extract version from tag (remove 'v' prefix)
          VERSION="${GITHUB_REF#refs/tags/v}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Building consolidated release for version: $VERSION"

      - name: Download all artifacts
        uses: actions/download-artifact@v6
        with:
          path: artifacts/

      - name: Organize artifacts
        env:
          VERSION: ${{ steps.version.outputs.version }}
        run: |
          echo "Organizing artifacts for release..."
          mkdir -p release-files

          # Copy all package files to release directory
          find artifacts/ -name "*.deb" -exec cp {} release-files/ \;
          find artifacts/ -name "*.rpm" -exec cp {} release-files/ \;
          find artifacts/ -name "*.pkg" -exec cp {} release-files/ \;
          find artifacts/ -name "*.apk" -exec cp {} release-files/ \;
          find artifacts/ -name "*.tar.gz" -exec cp {} release-files/ \;
          find artifacts/ -name "*.tgz" -exec cp {} release-files/ \;
          find artifacts/ -name "*.msi" -exec cp {} release-files/ \;
          find artifacts/ -name "*.sha256" -exec cp {} release-files/ \;
          find artifacts/ -name "*.json" -exec cp {} release-files/ \;

          echo "Release files:"
          ls -la release-files/

      - name: Push packages to sysmanage-docs repository
        env:
          VERSION: ${{ steps.version.outputs.version }}
          DOCS_REPO_TOKEN: ${{ secrets.DOCS_REPO_TOKEN }}
        run: |
          echo "Cloning sysmanage-docs repository..."
          git clone https://x-access-token:${DOCS_REPO_TOKEN}@github.com/bceverly/sysmanage-docs.git /tmp/sysmanage-docs

          cd /tmp/sysmanage-docs
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"

          # Create version directory for server packages
          mkdir -p "repo/server/deb/pool/main/$VERSION-1"
          mkdir -p "repo/server/openbsd/$VERSION"
          mkdir -p "repo/server/freebsd/$VERSION"
          mkdir -p "repo/server/netbsd/$VERSION"
          mkdir -p "repo/server/macos/$VERSION"
          mkdir -p "repo/server/rpm/centos/$VERSION"
          mkdir -p "repo/server/rpm/opensuse/$VERSION"
          mkdir -p "repo/server/windows/$VERSION"
          mkdir -p "repo/server/alpine/$VERSION"

          # Copy package files to appropriate locations
          # DEB packages
          cp ${{ github.workspace }}/release-files/sysmanage_*.deb "repo/server/deb/pool/main/$VERSION-1/" 2>/dev/null || true
          cp ${{ github.workspace }}/release-files/sysmanage_*.deb.sha256 "repo/server/deb/pool/main/$VERSION-1/" 2>/dev/null || true

          # OpenBSD port tarballs
          cp ${{ github.workspace }}/release-files/sysmanage-openbsd-port-*.tar.gz "repo/server/openbsd/$VERSION/" 2>/dev/null || true
          cp ${{ github.workspace }}/release-files/sysmanage-openbsd-port-*.tar.gz.sha256 "repo/server/openbsd/$VERSION/" 2>/dev/null || true

          # FreeBSD packages
          cp ${{ github.workspace }}/release-files/sysmanage-*.pkg "repo/server/freebsd/$VERSION/" 2>/dev/null || true
          cp ${{ github.workspace }}/release-files/sysmanage-*.pkg.sha256 "repo/server/freebsd/$VERSION/" 2>/dev/null || true

          # macOS packages
          cp ${{ github.workspace }}/release-files/sysmanage-*-macos.pkg "repo/server/macos/$VERSION/" 2>/dev/null || true
          cp ${{ github.workspace }}/release-files/sysmanage-*-macos.pkg.sha256 "repo/server/macos/$VERSION/" 2>/dev/null || true

          # NetBSD packages
          cp ${{ github.workspace }}/release-files/sysmanage-*-netbsd.tgz "repo/server/netbsd/$VERSION/" 2>/dev/null || true
          cp ${{ github.workspace }}/release-files/sysmanage-*-netbsd.tgz.sha256 "repo/server/netbsd/$VERSION/" 2>/dev/null || true

          # RPM packages - separate CentOS and OpenSUSE by architecture pattern
          # CentOS RPMs typically have x86_64 or noarch in filename with el* dist tag
          cp ${{ github.workspace }}/release-files/sysmanage-*el*.rpm "repo/server/rpm/centos/$VERSION/" 2>/dev/null || true
          cp ${{ github.workspace }}/release-files/sysmanage-*el*.rpm.sha256 "repo/server/rpm/centos/$VERSION/" 2>/dev/null || true
          # OpenSUSE RPMs typically have noarch and no dist tag or suse dist tag
          cp ${{ github.workspace }}/release-files/sysmanage-$VERSION-*.noarch.rpm "repo/server/rpm/opensuse/$VERSION/" 2>/dev/null || true
          cp ${{ github.workspace }}/release-files/sysmanage-$VERSION-*.noarch.rpm.sha256 "repo/server/rpm/opensuse/$VERSION/" 2>/dev/null || true

          # Windows MSI packages
          cp ${{ github.workspace }}/release-files/sysmanage-*-windows-*.msi "repo/server/windows/$VERSION/" 2>/dev/null || true
          cp ${{ github.workspace }}/release-files/sysmanage-*-windows-*.msi.sha256 "repo/server/windows/$VERSION/" 2>/dev/null || true

          # Alpine Linux APK packages
          cp ${{ github.workspace }}/release-files/sysmanage-*-alpine*.apk "repo/server/alpine/$VERSION/" 2>/dev/null || true
          cp ${{ github.workspace }}/release-files/sysmanage-*-alpine*.apk.sha256 "repo/server/alpine/$VERSION/" 2>/dev/null || true

          # Install repository tools
          echo "Installing repository metadata tools..."
          sudo apt-get update && sudo apt-get install -y dpkg-dev

          # Regenerate apt repository metadata
          echo "Regenerating apt repository metadata..."
          cd repo/server/deb

          # Generate Packages files
          dpkg-scanpackages pool/ /dev/null > dists/stable/main/binary-amd64/Packages
          gzip -9c dists/stable/main/binary-amd64/Packages > dists/stable/main/binary-amd64/Packages.gz

          # Generate Release file with checksums
          cd dists/stable
          {
            echo "Date: $(date -R -u)"
            echo "MD5Sum:"
            md5sum main/binary-amd64/Packages | awk '{printf " %s %16d %s\n", $1, 0, $2}'
            md5sum main/binary-amd64/Packages.gz | awk '{printf " %s %16d %s\n", $1, 0, $2}'
            echo "SHA1:"
            sha1sum main/binary-amd64/Packages | awk '{printf " %s %16d %s\n", $1, 0, $2}'
            sha1sum main/binary-amd64/Packages.gz | awk '{printf " %s %16d %s\n", $1, 0, $2}'
            echo "SHA256:"
            sha256sum main/binary-amd64/Packages | awk '{printf " %s %16d %s\n", $1, 0, $2}'
            sha256sum main/binary-amd64/Packages.gz | awk '{printf " %s %16d %s\n", $1, 0, $2}'
            echo "SHA512:"
            sha512sum main/binary-amd64/Packages | awk '{printf " %s %16d %s\n", $1, 0, $2}'
            sha512sum main/binary-amd64/Packages.gz | awk '{printf " %s %16d %s\n", $1, 0, $2}'
          } > Release.tmp

          # Add file sizes to Release file
          SIZE_PACKAGES=$(stat -c%s main/binary-amd64/Packages)
          SIZE_PACKAGES_GZ=$(stat -c%s main/binary-amd64/Packages.gz)
          sed -i "s/ 0 main\/binary-amd64\/Packages$/ $SIZE_PACKAGES main\/binary-amd64\/Packages/" Release.tmp
          sed -i "s/ 0 main\/binary-amd64\/Packages.gz$/ $SIZE_PACKAGES_GZ main\/binary-amd64\/Packages.gz/" Release.tmp
          mv Release.tmp Release

          cd /tmp/sysmanage-docs

          # Commit and push changes
          git add .
          git commit -m "Add SysManage Server packages for v$VERSION" || echo "No changes to commit"
          git push origin main

      - name: Generate consolidated release notes
        id: release_notes
        env:
          VERSION: ${{ steps.version.outputs.version }}
        run: |
          # Get tag annotation message if it exists
          TAG_MESSAGE=$(git tag -l --format='%(contents)' ${{ github.ref_name }} | sed '/^$/d')

          cat > release_notes.md << EOF
          # SysManage Server v$VERSION

          ${TAG_MESSAGE:+$TAG_MESSAGE}
          ${TAG_MESSAGE:+}
          Multi-platform system management and monitoring server with web-based interface.

          ## Installation Instructions

          ### Ubuntu/Debian
          \`\`\`bash
          # Download and install
          wget https://github.com/${{ github.repository }}/releases/download/${{ github.ref_name }}/sysmanage_${VERSION}-1_all.deb
          sudo apt install ./sysmanage_${VERSION}-1_all.deb

          # Install nginx if not already installed
          sudo apt install nginx

          # Configure the server
          sudo nano /etc/sysmanage.yaml

          # Run database migrations
          cd /opt/sysmanage
          sudo -u sysmanage .venv/bin/python -m alembic upgrade head

          # Start the service
          sudo systemctl enable --now sysmanage
          \`\`\`

          ### OpenBSD
          \`\`\`bash
          # Download the port tarball
          wget https://github.com/${{ github.repository }}/releases/download/${{ github.ref_name }}/sysmanage-openbsd-port-${VERSION}.tar.gz

          # Extract to OpenBSD ports tree
          cd /usr/ports/mystuff
          mkdir -p www
          tar xzf ~/sysmanage-openbsd-port-${VERSION}.tar.gz -C www/

          # Generate checksums
          cd /usr/ports/mystuff/www/sysmanage
          doas make makesum

          # Build and install
          doas make install

          # Initialize PostgreSQL (if not already done)
          doas su - _postgresql
          initdb -D /var/postgresql/data -U postgres -A scram-sha-256 -E UTF8 -W
          exit
          doas rcctl enable postgresql
          doas rcctl start postgresql

          # Create database and user
          doas su - _postgresql -c "createuser -P sysmanage"
          doas su - _postgresql -c "createdb -O sysmanage sysmanage"

          # Configure SysManage
          doas vi /etc/sysmanage.yaml
          # Update the database connection string

          # Initialize database schema
          cd /usr/local/libexec/sysmanage
          doas python3 -m alembic upgrade head

          # Enable and start the service
          doas rcctl enable sysmanage
          doas rcctl start sysmanage
          \`\`\`

          ### FreeBSD
          \`\`\`bash
          # Download and install
          fetch https://github.com/${{ github.repository }}/releases/download/${{ github.ref_name }}/sysmanage-${VERSION}.pkg
          sudo pkg add ./sysmanage-${VERSION}.pkg

          # The package automatically installs nginx and PostgreSQL as dependencies
          # Initialize PostgreSQL (if not already done)
          sudo sysrc postgresql_enable=YES
          sudo service postgresql initdb
          sudo service postgresql start

          # Create database and user
          sudo su - postgres -c "createuser sysmanage"
          sudo su - postgres -c "createdb sysmanage -O sysmanage"
          sudo su - postgres -c "psql -c \\"ALTER USER sysmanage WITH PASSWORD 'your-password';\\""

          # Configure SysManage
          sudo vi /usr/local/etc/sysmanage/config.yaml
          # Update the database connection string

          # Run database migrations
          cd /usr/local/lib/sysmanage
          sudo -u sysmanage .venv/bin/python -m alembic upgrade head

          # Enable and start the services
          sudo sysrc sysmanage_enable=YES
          sudo sysrc nginx_enable=YES
          sudo service sysmanage start
          sudo service nginx start
          \`\`\`

          ### macOS
          \`\`\`bash
          # Download and install
          curl -L -O https://github.com/${{ github.repository }}/releases/download/${{ github.ref_name }}/sysmanage-${VERSION}-macos.pkg
          sudo installer -pkg sysmanage-${VERSION}-macos.pkg -target /

          # The installer automatically creates the virtual environment and copies files
          # Install PostgreSQL (if not already installed)
          brew install postgresql@16
          brew services start postgresql@16

          # Create database
          createdb sysmanage

          # Configure SysManage
          sudo cp /etc/sysmanage.yaml.example /etc/sysmanage.yaml
          sudo vi /etc/sysmanage.yaml
          # Update the database connection string

          # Run database migrations
          cd /usr/local/lib/sysmanage
          .venv/bin/python -m alembic upgrade head

          # Install and configure nginx (if not already installed)
          brew install nginx
          cp /usr/local/etc/sysmanage/sysmanage-nginx.conf /usr/local/etc/nginx/servers/
          brew services start nginx

          # Load and start the service
          sudo launchctl load /Library/LaunchDaemons/com.sysmanage.server.plist
          \`\`\`

          ### NetBSD
          \`\`\`bash
          # Download and verify
          ftp https://github.com/${{ github.repository }}/releases/download/${{ github.ref_name }}/sysmanage-${VERSION}-netbsd.tgz
          ftp https://github.com/${{ github.repository }}/releases/download/${{ github.ref_name }}/sysmanage-${VERSION}-netbsd.tgz.sha256
          sha256 -c sysmanage-${VERSION}-netbsd.tgz.sha256 sysmanage-${VERSION}-netbsd.tgz

          # Install package
          su -
          pkg_add sysmanage-${VERSION}-netbsd.tgz

          # The package automatically installs PostgreSQL 16 and nginx as dependencies
          # Initialize PostgreSQL (if not already done)
          /etc/rc.d/pgsql initdb
          echo "pgsql=YES" >> /etc/rc.conf
          /etc/rc.d/pgsql start

          # Create database and user
          su - pgsql -c "createuser -P sysmanage"
          su - pgsql -c "createdb -O sysmanage sysmanage"

          # Configure SysManage
          cp /usr/pkg/etc/sysmanage/sysmanage.yaml.example /usr/pkg/etc/sysmanage.yaml
          vi /usr/pkg/etc/sysmanage.yaml
          # Update the database connection string

          # Initialize database schema
          cd /usr/pkg/lib/sysmanage
          python3.12 -m venv .venv
          .venv/bin/pip install -r requirements.txt
          .venv/bin/python -m alembic upgrade head

          # Configure nginx (optional)
          cp /usr/pkg/share/examples/sysmanage/sysmanage-nginx.conf /usr/pkg/etc/nginx/sites-enabled/
          echo "nginx=YES" >> /etc/rc.conf

          # Enable and start the services
          cp /usr/pkg/share/examples/rc.d/sysmanage /etc/rc.d/
          chmod +x /etc/rc.d/sysmanage
          echo "sysmanage=YES" >> /etc/rc.conf
          /etc/rc.d/sysmanage start
          /etc/rc.d/nginx start
          \`\`\`

          ### CentOS/RHEL/Fedora/Rocky Linux/AlmaLinux
          \`\`\`bash
          # Download and install
          wget https://github.com/${{ github.repository }}/releases/download/${{ github.ref_name }}/sysmanage-${VERSION}-1.*.rpm
          sudo dnf install ./sysmanage-${VERSION}-1.*.rpm

          # The package automatically installs nginx and PostgreSQL as dependencies
          # Initialize PostgreSQL (if not already done)
          sudo postgresql-setup --initdb
          sudo systemctl enable --now postgresql

          # Create database and user
          sudo -u postgres createuser sysmanage
          sudo -u postgres createdb sysmanage -O sysmanage
          sudo -u postgres psql -c "ALTER USER sysmanage WITH PASSWORD 'your-password';"

          # Configure SysManage
          sudo vi /etc/sysmanage.yaml
          # Update the database connection string

          # Initialize database schema
          cd /opt/sysmanage
          sudo -u sysmanage .venv/bin/python -m alembic upgrade head

          # Start the services
          sudo systemctl enable --now sysmanage
          sudo systemctl enable --now nginx
          \`\`\`

          ### OpenSUSE/SLES
          \`\`\`bash
          # Download and install
          wget https://github.com/${{ github.repository }}/releases/download/${{ github.ref_name }}/sysmanage-${VERSION}-1.noarch.rpm
          sudo zypper install ./sysmanage-${VERSION}-1.noarch.rpm

          # The package automatically installs nginx and PostgreSQL as dependencies
          # Initialize and start PostgreSQL (if not already done)
          sudo systemctl enable --now postgresql

          # Create database and user
          sudo -u postgres createuser sysmanage
          sudo -u postgres createdb sysmanage -O sysmanage
          sudo -u postgres psql -c "ALTER USER sysmanage WITH PASSWORD 'your-password';"

          # Configure SysManage
          sudo vi /etc/sysmanage.yaml
          # Update the database connection string

          # Initialize database schema
          cd /opt/sysmanage
          sudo -u sysmanage .venv/bin/python -m alembic upgrade head

          # Start the services
          sudo systemctl enable --now sysmanage
          sudo systemctl enable --now nginx
          \`\`\`

          ### Alpine Linux (3.19, 3.20, 3.21)
          \`\`\`bash
          # Download the APK package for your Alpine version (e.g., alpine319, alpine320, alpine321)
          wget https://github.com/${{ github.repository }}/releases/download/${{ github.ref_name }}/sysmanage-${VERSION}-alpine320.apk

          # Allow installation of unsigned packages (required for GitHub releases)
          apk add --allow-untrusted ./sysmanage-${VERSION}-alpine320.apk

          # The package installs to /usr/libexec/sysmanage with pip packages in a subdirectory
          # Dependencies: python3, nginx, postgresql are automatically installed

          # Initialize and start PostgreSQL
          rc-update add postgresql default
          rc-service postgresql start

          # Create database and user
          su - postgres -c "createuser -P sysmanage"
          su - postgres -c "createdb -O sysmanage sysmanage"

          # Configure SysManage
          cp /etc/sysmanage/sysmanage.yaml.example /etc/sysmanage/sysmanage.yaml
          vi /etc/sysmanage/sysmanage.yaml
          # Update the database connection string

          # Initialize database schema
          cd /usr/libexec/sysmanage
          PYTHONPATH=/usr/libexec/sysmanage/pip-packages python3 -m alembic upgrade head

          # Enable and start the services
          rc-update add sysmanage default
          rc-update add nginx default
          rc-service sysmanage start
          rc-service nginx start
          \`\`\`

          ### Windows (x64 and ARM64)
          \`\`\`powershell
          # Download the MSI installer (choose your architecture)
          # For x64:
          Invoke-WebRequest -Uri "https://github.com/${{ github.repository }}/releases/download/${{ github.ref_name }}/sysmanage-${VERSION}-windows-x64.msi" -OutFile "sysmanage-${VERSION}-windows-x64.msi"

          # For ARM64:
          Invoke-WebRequest -Uri "https://github.com/${{ github.repository }}/releases/download/${{ github.ref_name }}/sysmanage-${VERSION}-windows-arm64.msi" -OutFile "sysmanage-${VERSION}-windows-arm64.msi"

          # Install the MSI package (run as Administrator)
          # The installer will:
          # - Check for and install Python 3.12 if needed
          # - Install Visual C++ Redistributable if needed
          # - Extract application files to C:\Program Files\SysManage Server
          # - Create Python virtual environment and install dependencies
          # - Create Windows Service "SysManageServer"
          # - Start the service automatically

          msiexec /i sysmanage-${VERSION}-windows-x64.msi

          # Configure SysManage (installer creates example config)
          notepad "C:\ProgramData\SysManage\sysmanage.yaml"
          # Update database connection string and other settings

          # The service runs automatically. To manage it:
          # Stop the service:
          Stop-Service SysManageServer

          # Start the service:
          Start-Service SysManageServer

          # Check service status:
          Get-Service SysManageServer

          # View service logs:
          Get-Content "C:\ProgramData\SysManage\logs\sysmanage-service.log" -Tail 50

          # To uninstall:
          # Use "Add or Remove Programs" or run:
          msiexec /x sysmanage-${VERSION}-windows-x64.msi
          \`\`\`

          **Note for Windows**: The installer requires administrator privileges. Python 3.12 and Visual C++ Redistributable will be automatically installed if not present. The service runs on port 8080 by default (configurable in sysmanage.yaml).

          ## Access the Web Interface

          After configuration and starting the service:
          - Frontend: http://localhost:3000
          - Backend API: http://localhost:8080

          ## Checksum Verification

          All packages include SHA256 checksums. Download both files and verify:

          **Linux (Ubuntu/Debian):**
          \`\`\`bash
          sha256sum -c sysmanage_${VERSION}-1_all.deb.sha256
          \`\`\`

          **OpenBSD:**
          \`\`\`bash
          sha256 -C sysmanage-openbsd-port-${VERSION}.tar.gz.sha256 sysmanage-openbsd-port-${VERSION}.tar.gz
          \`\`\`

          **FreeBSD:**
          \`\`\`bash
          sha256 -c sysmanage-${VERSION}.pkg.sha256 sysmanage-${VERSION}.pkg
          \`\`\`

          **macOS:**
          \`\`\`bash
          shasum -a 256 -c sysmanage-${VERSION}-macos.pkg.sha256
          \`\`\`

          **NetBSD:**
          \`\`\`bash
          sha256 -c sysmanage-${VERSION}-netbsd.tgz.sha256 sysmanage-${VERSION}-netbsd.tgz
          \`\`\`

          **CentOS/RHEL/Fedora:**
          \`\`\`bash
          sha256sum -c sysmanage-${VERSION}-1.*.rpm.sha256
          \`\`\`

          **OpenSUSE/SLES:**
          \`\`\`bash
          sha256sum -c sysmanage-${VERSION}-1.noarch.rpm.sha256
          \`\`\`

          **Alpine Linux:**
          \`\`\`bash
          # For Alpine 3.19:
          sha256sum -c sysmanage-${VERSION}-alpine319.apk.sha256

          # For Alpine 3.20:
          sha256sum -c sysmanage-${VERSION}-alpine320.apk.sha256

          # For Alpine 3.21:
          sha256sum -c sysmanage-${VERSION}-alpine321.apk.sha256
          \`\`\`

          **Windows:**
          \`\`\`powershell
          # For x64:
          certutil -hashfile sysmanage-${VERSION}-windows-x64.msi SHA256
          # Compare output with sysmanage-${VERSION}-windows-x64.msi.sha256

          # For ARM64:
          certutil -hashfile sysmanage-${VERSION}-windows-arm64.msi SHA256
          # Compare output with sysmanage-${VERSION}-windows-arm64.msi.sha256

          # Or using PowerShell:
          (Get-FileHash sysmanage-${VERSION}-windows-x64.msi -Algorithm SHA256).Hash
          \`\`\`

          ## Software Bill of Materials (SBOM)

          This release includes comprehensive Software Bill of Materials (SBOM) files in CycloneDX JSON format for supply chain security and vulnerability analysis:

          **Standalone Downloads:**
          - **backend-sbom.json** - Complete inventory of Python dependencies
          - **frontend-sbom.json** - Complete inventory of Node.js dependencies

          **Download and inspect:**
          \`\`\`bash
          # Download SBOM files
          wget https://github.com/${{ github.repository }}/releases/download/${{ github.ref_name }}/backend-sbom.json
          wget https://github.com/${{ github.repository }}/releases/download/${{ github.ref_name }}/frontend-sbom.json

          # View with jq (if installed)
          cat backend-sbom.json | jq .
          cat frontend-sbom.json | jq .
          \`\`\`

          These SBOM files are compatible with vulnerability scanning tools (Grype, Trivy, Dependency-Track, etc.) and provide complete transparency of all software dependencies. The SBOM files are also embedded in the .deb package at \`/usr/share/doc/sysmanage/sbom/\`.

          ## System Requirements

          - **Operating System**: Ubuntu 22.04+, Debian 11+, Alpine Linux 3.19+, and other supported platforms
          - **Database**: PostgreSQL 12+ (recommended) or SQLite
          - **Web Server**: Nginx (for serving frontend)
          - **Python**: 3.10+ (included in package)
          - **Node.js**: Not required at runtime (frontend pre-built)

          ## What's Included

          - Backend API server with WebSocket support
          - React-based web frontend (pre-built)
          - Systemd service configuration (for Linux distros with systemd)
          - OpenRC service configuration (for Alpine Linux)
          - Nginx configuration template
          - Alembic database migrations
          - Example configuration file
          - Certificate storage directory
          - Comprehensive i18n support (14 languages)
          - Software Bill of Materials (SBOM) in CycloneDX format

          ## Configuration

          The server uses \`/etc/sysmanage.yaml\` for configuration. Key settings:

          - Database connection (PostgreSQL recommended for production)
          - Listen addresses and ports
          - SSL/TLS certificates
          - Graylog integration (optional)
          - Authentication settings
          - Logging configuration

          ## Post-Installation Steps

          1. Configure database connection in \`/etc/sysmanage.yaml\`
          2. Run database migrations: \`cd /opt/sysmanage && sudo -u sysmanage .venv/bin/python -m alembic upgrade head\`
          3. Start the service: \`sudo systemctl start sysmanage\`
          4. Configure nginx to proxy requests to the backend
          5. Access the web interface at configured URL

          ## Documentation

          Full documentation is available at: https://sysmanage.org

          EOF

      - name: Create consolidated GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          files: release-files/*
          body_path: release_notes.md
          make_latest: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Deploy to Launchpad PPA - Matrix strategy for parallel uploads
  deploy-launchpad:
    name: Deploy to Launchpad PPA (${{ matrix.release_name }})
    runs-on: ubuntu-22.04
    needs: [release]
    if: startsWith(github.ref, 'refs/tags/')
    strategy:
      matrix:
        include:
          - release: questing
            release_name: "25.10 Questing"
          - release: plucky
            release_name: "25.04 Plucky"
          - release: noble
            release_name: "24.04 Noble"
          - release: jammy
            release_name: "22.04 Jammy"

    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Determine version
        id: version
        run: |
          VERSION="${GITHUB_REF#refs/tags/v}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Deploying version $VERSION to Launchpad PPA"

      - name: Set up Python 3.12
        uses: actions/setup-python@v6
        with:
          python-version: '3.12'

      - name: Set up Node.js
        uses: actions/setup-node@v5
        with:
          node-version: '20'

      - name: Install packaging tools
        run: |
          sudo apt-get update
          sudo apt-get install -y devscripts debhelper dh-python python3-all python3-setuptools dput-ng gnupg

      - name: Import GPG key
        env:
          GPG_PRIVATE_KEY: ${{ secrets.LAUNCHPAD_GPG_KEY }}
          GPG_PASSPHRASE: ${{ secrets.LAUNCHPAD_GPG_PASSPHRASE }}
        run: |
          # Check if GPG key secret is set
          if [ -z "$GPG_PRIVATE_KEY" ]; then
            echo "ERROR: LAUNCHPAD_GPG_KEY secret is not set!"
            exit 1
          fi

          # Create GPG directory if it doesn't exist
          mkdir -p ~/.gnupg
          chmod 700 ~/.gnupg

          # Import the GPG key
          echo "Importing GPG key..."
          echo "$GPG_PRIVATE_KEY" | gpg --batch --import 2>&1 || \
            echo "$GPG_PRIVATE_KEY" | base64 -d | gpg --batch --import 2>&1

          # Configure GPG for non-interactive use
          cat >> ~/.gnupg/gpg.conf << GPGEOF
          use-agent
          pinentry-mode loopback
          GPGEOF

          cat >> ~/.gnupg/gpg-agent.conf << GPGEOF
          allow-loopback-pinentry
          allow-preset-passphrase
          GPGEOF

          # Restart GPG agent
          gpg-connect-agent reloadagent /bye

          # List imported keys
          echo "Imported GPG keys:"
          gpg --list-secret-keys --keyid-format LONG

          # Get the key ID for later use
          GPG_KEY_ID=$(gpg --list-secret-keys --keyid-format LONG | grep sec | awk '{print $2}' | cut -d'/' -f2 | head -1)
          echo "GPG_KEY_ID=$GPG_KEY_ID" >> $GITHUB_ENV
          echo "Using GPG key: $GPG_KEY_ID"

      - name: Configure dput for Launchpad
        run: |
          mkdir -p ~/.dput.d/profiles
          cat > ~/.dput.d/profiles/launchpad.json << 'DPUTEOF'
          {
            "fqdn": "ppa.launchpad.net",
            "incoming": "~bceverly/ubuntu/sysmanage",
            "method": "ftp",
            "allow_unsigned_uploads": false
          }
          DPUTEOF

      - name: Generate requirements-prod.txt
        run: |
          echo "Generating requirements-prod.txt from requirements.txt..."
          python3 scripts/update-requirements-prod.py

      - name: Install SBOM generation tools
        run: |
          # Install cyclonedx-bom for Python
          python3 -m pip install cyclonedx-bom

          # Install cyclonedx-npm globally for Node.js
          sudo npm install -g @cyclonedx/cyclonedx-npm

          # Verify installations
          python3 -c "import cyclonedx_py; print('cyclonedx-bom installed')"
          cyclonedx-npm --version

      - name: Build frontend
        working-directory: frontend
        run: |
          echo "Installing frontend dependencies..."
          npm ci --legacy-peer-deps

          echo "Building frontend..."
          npm run build

      - name: Generate SBOM files
        run: |
          echo "Generating SBOM files..."
          make sbom

      - name: Build and upload source package
        env:
          VERSION: ${{ steps.version.outputs.version }}
          DEBFULLNAME: "Bryan Everly"
          DEBEMAIL: "bryan@theeverlys.com"
          RELEASE: ${{ matrix.release }}
        run: |
          # Get GPG key ID
          GPG_KEY_ID=$(gpg --list-secret-keys --keyid-format LONG | grep sec | awk '{print $2}' | cut -d'/' -f2 | head -1)

          echo "=========================================="
          echo "Building source package for Ubuntu $RELEASE (${{ matrix.release_name }})"
          echo "Version: $VERSION"
          echo "=========================================="

          # Create working directory
          WORK_DIR="/tmp/sysmanage-$RELEASE"
          rm -rf "$WORK_DIR"
          mkdir -p "$WORK_DIR"

          # Copy source to working directory, excluding node_modules
          # (node_modules contains minified files that trigger lintian source-is-missing errors)
          rsync -a --exclude 'node_modules' --exclude '.git' . "$WORK_DIR/"
          cd "$WORK_DIR"

          # Copy debian directory
          if [ -d "installer/ubuntu/debian" ]; then
            cp -r installer/ubuntu/debian .
          else
            echo "Error: debian directory not found"
            exit 1
          fi

          # Update changelog
          dch -v "${VERSION}+ppa1~${RELEASE}1" -D "$RELEASE" "New upstream release ${VERSION}"

          # Build source package (unsigned, skip dependency check)
          debuild -S -sa -us -uc -d

          # Move to /tmp where files are
          cd ..

          # Create a temporary passphrase file for GPG
          echo "${{ secrets.LAUNCHPAD_GPG_PASSPHRASE }}" > /tmp/gpg-passphrase-${RELEASE}

          # Sign with passphrase from file
          debsign --re-sign -p"gpg --batch --yes --passphrase-file /tmp/gpg-passphrase-${RELEASE}" \
            -k"$GPG_KEY_ID" sysmanage_${VERSION}+ppa1~${RELEASE}1_source.changes

          # Clean up passphrase file
          rm -f /tmp/gpg-passphrase-${RELEASE}

          # Upload to Launchpad PPA
          dput launchpad "sysmanage_${VERSION}+ppa1~${RELEASE}1_source.changes"

          echo "SUCCESS! Uploaded to Launchpad PPA for $RELEASE"

  # Deploy to OBS (openSUSE Build Service) - runs in parallel with Launchpad
  deploy-obs:
    name: Deploy to OBS
    runs-on: ubuntu-latest
    needs: [release]
    if: startsWith(github.ref, 'refs/tags/')

    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          ref: ${{ github.ref }}
          fetch-depth: 0

      - name: Determine version
        id: version
        run: |
          VERSION="${GITHUB_REF#refs/tags/v}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Deploying version $VERSION to OBS"

      - name: Set up Python 3.12
        uses: actions/setup-python@v6
        with:
          python-version: '3.12'

      - name: Set up Node.js
        uses: actions/setup-node@v5
        with:
          node-version: '20'

      - name: Install OBS tools
        run: |
          sudo apt-get update
          sudo apt-get install -y osc

      - name: Configure OBS credentials
        env:
          OBS_USERNAME: ${{ secrets.OBS_USERNAME }}
          OBS_PASSWORD: ${{ secrets.OBS_PASSWORD }}
        run: |
          if [ -z "$OBS_USERNAME" ] || [ -z "$OBS_PASSWORD" ]; then
            echo "ERROR: OBS credentials not set!"
            echo "Please set the following secrets:"
            echo "  - OBS_USERNAME (your openSUSE Build Service username)"
            echo "  - OBS_PASSWORD (your openSUSE Build Service password)"
            exit 1
          fi

          mkdir -p ~/.config/osc
          cat > ~/.config/osc/oscrc << EOF
          [general]
          apiurl = https://api.opensuse.org

          [https://api.opensuse.org]
          user = $OBS_USERNAME
          pass = $OBS_PASSWORD
          EOF
          chmod 600 ~/.config/osc/oscrc

          echo "OBS credentials configured for user: $OBS_USERNAME"

      - name: Checkout OBS package
        env:
          OBS_USERNAME: ${{ secrets.OBS_USERNAME }}
        run: |
          echo "Checking out OBS package home:${OBS_USERNAME}/sysmanage"
          osc checkout home:${OBS_USERNAME}/sysmanage
          cd home:${OBS_USERNAME}/sysmanage
          echo "Current OBS package contents:"
          ls -la

      - name: Generate requirements-prod.txt
        run: |
          echo "Generating requirements-prod.txt from requirements.txt..."
          python3 scripts/update-requirements-prod.py

      - name: Build frontend
        working-directory: frontend
        run: |
          echo "Installing frontend dependencies..."
          npm ci --legacy-peer-deps

          echo "Building frontend..."
          npm run build

          echo "Frontend build complete"
          ls -lh dist/ | head -10

      - name: Verify frontend build
        run: |
          if [ ! -d "frontend/dist" ]; then
            echo "ERROR: frontend/dist directory does not exist!"
            echo "Checking frontend directory contents:"
            ls -la frontend/
            exit 1
          fi
          echo "Frontend build directory verified"
          echo "Build directory size: $(du -sh frontend/dist)"

      - name: Update package files
        env:
          VERSION: ${{ steps.version.outputs.version }}
          OBS_USERNAME: ${{ secrets.OBS_USERNAME }}
          WORKSPACE: ${{ github.workspace }}
        run: |
          cd home:${OBS_USERNAME}/sysmanage

          # Copy spec file and rpmlintrc (if it exists)
          echo "Copying spec file from installer/opensuse/"
          cp $WORKSPACE/installer/opensuse/sysmanage.spec .
          if [ -f $WORKSPACE/installer/opensuse/sysmanage-rpmlintrc ]; then
            echo "Copying rpmlintrc"
            cp $WORKSPACE/installer/opensuse/sysmanage-rpmlintrc .
          fi

          # Update version in spec file
          echo "Updating version to $VERSION in spec file"
          sed -i "s/^Version:.*/Version:        $VERSION/" sysmanage.spec

          # Create source tarball (OBS needs the source)
          echo "Creating source tarball..."
          TAR_NAME="sysmanage-$VERSION"
          mkdir -p /tmp/$TAR_NAME

          # Copy backend source files
          echo "Copying backend source files..."
          cp -r $WORKSPACE/backend /tmp/$TAR_NAME/
          cp -r $WORKSPACE/alembic /tmp/$TAR_NAME/
          cp $WORKSPACE/alembic.ini /tmp/$TAR_NAME/
          cp -r $WORKSPACE/config /tmp/$TAR_NAME/
          cp -r $WORKSPACE/scripts /tmp/$TAR_NAME/
          cp $WORKSPACE/requirements.txt /tmp/$TAR_NAME/
          cp $WORKSPACE/requirements-prod.txt /tmp/$TAR_NAME/
          cp $WORKSPACE/README.md /tmp/$TAR_NAME/ || touch /tmp/$TAR_NAME/README.md
          cp $WORKSPACE/LICENSE /tmp/$TAR_NAME/ || touch /tmp/$TAR_NAME/LICENSE

          # Copy frontend build
          echo "Copying frontend build..."
          mkdir -p /tmp/$TAR_NAME/frontend
          cp -r $WORKSPACE/frontend/dist /tmp/$TAR_NAME/frontend/
          cp -r $WORKSPACE/frontend/public /tmp/$TAR_NAME/frontend/
          cp $WORKSPACE/frontend/package.json /tmp/$TAR_NAME/frontend/ || true

          # Copy installer files
          echo "Copying installer files..."
          mkdir -p /tmp/$TAR_NAME/installer/opensuse
          cp $WORKSPACE/installer/opensuse/*.service /tmp/$TAR_NAME/installer/opensuse/ || true
          cp $WORKSPACE/installer/opensuse/*.sudoers /tmp/$TAR_NAME/installer/opensuse/ || true
          cp $WORKSPACE/installer/opensuse/*.example /tmp/$TAR_NAME/installer/opensuse/ || true
          cp $WORKSPACE/installer/opensuse/sysmanage-nginx.conf /tmp/$TAR_NAME/installer/opensuse/ || true

          # Create tarball
          cd /tmp
          tar czf sysmanage-$VERSION.tar.gz $TAR_NAME/
          echo "Created tarball: sysmanage-$VERSION.tar.gz ($(du -h sysmanage-$VERSION.tar.gz | cut -f1))"
          echo "Tarball contents:"
          tar tzf sysmanage-$VERSION.tar.gz | head -20

          # Create vendor tarball for offline installation
          echo "Creating vendor tarball with pip dependencies..."
          mkdir -p /tmp/vendor

          # Pass 1: Download Python 3.11 wheels for manylinux
          echo "Pass 1: Downloading Python 3.11 wheels for manylinux..."
          pip3 download -r $WORKSPACE/requirements-prod.txt -d /tmp/vendor \
            --python-version 311 \
            --platform manylinux2014_x86_64 \
            --platform manylinux_2_17_x86_64 \
            --only-binary=:all:

          # Pass 2: Download source distributions for pure Python packages without wheels
          echo "Pass 2: Downloading source distributions for packages without wheels..."
          pip3 download -r $WORKSPACE/requirements-prod.txt -d /tmp/vendor \
            --python-version 311 \
            --no-binary :all: 2>/dev/null || true

          echo ""
          echo "Downloaded packages (total: $(ls /tmp/vendor/ | wc -l)):"
          echo "Vendor tarball contains $(ls -1 /tmp/vendor/*.whl 2>/dev/null | wc -l) wheels and $(ls -1 /tmp/vendor/*.tar.gz 2>/dev/null | wc -l) source packages"

          cd /tmp
          tar czf sysmanage-vendor-$VERSION.tar.gz vendor/
          echo "Created vendor tarball: sysmanage-vendor-$VERSION.tar.gz ($(du -h sysmanage-vendor-$VERSION.tar.gz | cut -f1))"

          # Copy both tarballs to OBS directory
          cp sysmanage-$VERSION.tar.gz $GITHUB_WORKSPACE/home:${OBS_USERNAME}/sysmanage/
          cp sysmanage-vendor-$VERSION.tar.gz $GITHUB_WORKSPACE/home:${OBS_USERNAME}/sysmanage/

          cd $GITHUB_WORKSPACE/home:${OBS_USERNAME}/sysmanage

          echo "OBS package directory contents:"
          ls -lh

          # Remove old tarballs (keep spec and rpmlintrc)
          echo "Removing old tarballs..."
          osc remove *.tar.gz 2>/dev/null || true

          # Add new files
          echo "Adding new files to OBS..."
          osc add sysmanage-$VERSION.tar.gz
          osc add sysmanage-vendor-$VERSION.tar.gz
          osc add sysmanage.spec
          if [ -f sysmanage-rpmlintrc ]; then
            osc add sysmanage-rpmlintrc
          fi

          echo "Files staged for OBS:"
          osc status

      - name: Commit and push to OBS
        env:
          VERSION: ${{ steps.version.outputs.version }}
          OBS_USERNAME: ${{ secrets.OBS_USERNAME }}
        run: |
          cd home:${OBS_USERNAME}/sysmanage

          echo "Committing to OBS..."
          osc commit -m "Release version $VERSION"

          echo ""
          echo "=========================================="
          echo "SUCCESS! Uploaded version $VERSION to OBS"
          echo "=========================================="
          echo ""
          echo "View build status at:"
          echo "https://build.opensuse.org/package/show/home:${OBS_USERNAME}/sysmanage"
          echo ""
          echo "OBS will now build for all configured targets:"
          echo "  - openSUSE Tumbleweed"
          echo "  - openSUSE Leap 15.6"
          echo "  - openSUSE Leap 15.5"
          echo "  - SLE 15 SP6"
          echo "  - SLE 15 SP5"
          echo "=========================================="

  # Deploy to COPR (Fedora Community Build Service) - runs in parallel with OBS, Launchpad, Snap
  deploy-copr:
    name: Deploy to COPR
    runs-on: ubuntu-latest
    needs: [release]
    if: startsWith(github.ref, 'refs/tags/')

    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Determine version
        id: version
        run: |
          VERSION="${GITHUB_REF#refs/tags/v}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Deploying version $VERSION to COPR"

      - name: Set up Node.js for frontend build
        uses: actions/setup-node@v6
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Set up Python 3.12
        uses: actions/setup-python@v6
        with:
          python-version: '3.12'

      - name: Install Copr CLI and build tools
        run: |
          sudo apt-get update
          sudo apt-get install -y python3-pip rpm

          # Install copr-cli via pip (not available in Ubuntu repos)
          pip3 install copr-cli

          # Add pip binaries to PATH
          echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Configure Copr credentials
        env:
          COPR_LOGIN: ${{ secrets.COPR_LOGIN }}
          COPR_API_TOKEN: ${{ secrets.COPR_API_TOKEN }}
          COPR_USERNAME: ${{ secrets.COPR_USERNAME }}
        run: |
          if [ -z "$COPR_LOGIN" ] || [ -z "$COPR_API_TOKEN" ] || [ -z "$COPR_USERNAME" ]; then
            echo "ERROR: Copr credentials not set!"
            echo "Please set COPR_LOGIN, COPR_API_TOKEN, and COPR_USERNAME secrets"
            exit 1
          fi

          mkdir -p ~/.config
          cat > ~/.config/copr << 'EOF'
          [copr-cli]
          login = $COPR_LOGIN
          username = $COPR_USERNAME
          token = $COPR_API_TOKEN
          copr_url = https://copr.fedorainfracloud.org
          EOF

          # Substitute variables in the config file
          sed -i "s/\$COPR_LOGIN/$COPR_LOGIN/" ~/.config/copr
          sed -i "s/\$COPR_USERNAME/$COPR_USERNAME/" ~/.config/copr
          sed -i "s/\$COPR_API_TOKEN/$COPR_API_TOKEN/" ~/.config/copr

          chmod 600 ~/.config/copr

          echo "Copr credentials configured for user: $COPR_USERNAME"

      - name: Test Copr credentials
        env:
          COPR_USERNAME: ${{ secrets.COPR_USERNAME }}
        run: |
          echo "Testing Copr API connection..."
          copr-cli whoami
          echo ""
          echo "Listing user projects..."
          copr-cli list $COPR_USERNAME || echo "No projects yet or connection issue"

      - name: Build frontend
        run: |
          cd frontend
          npm ci
          npm run build
          echo "Frontend build complete"
          ls -la dist/

      - name: Prepare source files
        env:
          VERSION: ${{ steps.version.outputs.version }}
          WORKSPACE: ${{ github.workspace }}
        run: |
          echo "Preparing source files for version $VERSION"

          # Generate requirements-prod.txt from requirements.txt (excludes dev dependencies)
          echo "Generating requirements-prod.txt..."
          python3 $WORKSPACE/scripts/update-requirements-prod.py
          echo ""
          echo "Production requirements:"
          cat requirements-prod.txt

          # Create source tarball
          echo "Creating source tarball..."
          TAR_NAME="sysmanage-$VERSION"
          mkdir -p /tmp/$TAR_NAME

          # Copy backend files
          cp -r $WORKSPACE/backend /tmp/$TAR_NAME/
          cp -r $WORKSPACE/alembic /tmp/$TAR_NAME/
          cp $WORKSPACE/alembic.ini /tmp/$TAR_NAME/
          cp $WORKSPACE/requirements.txt /tmp/$TAR_NAME/
          cp $WORKSPACE/requirements-prod.txt /tmp/$TAR_NAME/
          cp -r $WORKSPACE/config /tmp/$TAR_NAME/
          cp -r $WORKSPACE/scripts /tmp/$TAR_NAME/

          # Copy frontend files
          mkdir -p /tmp/$TAR_NAME/frontend
          cp -r $WORKSPACE/frontend/dist /tmp/$TAR_NAME/frontend/
          cp -r $WORKSPACE/frontend/public /tmp/$TAR_NAME/frontend/

          # Copy installer files
          mkdir -p /tmp/$TAR_NAME/installer/centos
          cp $WORKSPACE/installer/centos/*.service /tmp/$TAR_NAME/installer/centos/ 2>/dev/null || true
          cp $WORKSPACE/installer/centos/*.conf /tmp/$TAR_NAME/installer/centos/ 2>/dev/null || true
          cp $WORKSPACE/installer/centos/*.example /tmp/$TAR_NAME/installer/centos/ 2>/dev/null || true

          # Copy documentation
          cp $WORKSPACE/README.md /tmp/$TAR_NAME/ || touch /tmp/$TAR_NAME/README.md
          cp $WORKSPACE/LICENSE /tmp/$TAR_NAME/ || touch /tmp/$TAR_NAME/LICENSE

          # Copy SBOM files if they exist
          if [ -d "$WORKSPACE/sbom" ]; then
            cp -r $WORKSPACE/sbom /tmp/$TAR_NAME/
          fi

          # Create tarball
          cd /tmp
          tar czf sysmanage-$VERSION.tar.gz $TAR_NAME/
          echo "Created tarball: sysmanage-$VERSION.tar.gz ($(du -h sysmanage-$VERSION.tar.gz | cut -f1))"

          # Create vendor tarball with wheels for Python 3.12 and 3.13
          echo ""
          echo "Creating vendor tarball with pip dependencies..."
          mkdir -p /tmp/vendor

          # Download wheels for Python 3.12 (EPEL 10)
          echo "Downloading wheels for Python 3.12 (EPEL 10)..."
          pip3 download -r $WORKSPACE/requirements-prod.txt -d /tmp/vendor --python-version 3.12.11 --platform manylinux2014_x86_64 --platform manylinux_2_17_x86_64 --only-binary=:all:
          echo "Downloaded wheels for Python 3.12"

          # Download wheels for Python 3.13 (Fedora 41, 42)
          echo ""
          echo "Downloading wheels for Python 3.13 (Fedora 41, 42)..."
          pip3 download -r $WORKSPACE/requirements-prod.txt -d /tmp/vendor --python-version 3.13.1 --platform manylinux2014_x86_64 --platform manylinux_2_17_x86_64 --only-binary=:all:
          echo "Downloaded wheels for Python 3.13"

          # Verify packages
          WHEEL_COUNT=$(ls -1 /tmp/vendor/*.whl 2>/dev/null | wc -l)
          echo ""
          echo "Total wheels in vendor directory: $WHEEL_COUNT"

          # Create vendor tarball
          cd /tmp
          tar czf sysmanage-vendor-$VERSION.tar.gz vendor/
          echo "Created vendor tarball: sysmanage-vendor-$VERSION.tar.gz ($(du -h sysmanage-vendor-$VERSION.tar.gz | cut -f1))"

          # Copy to rpmbuild directory
          mkdir -p ~/rpmbuild/SOURCES
          cp sysmanage-$VERSION.tar.gz ~/rpmbuild/SOURCES/
          cp sysmanage-vendor-$VERSION.tar.gz ~/rpmbuild/SOURCES/

      - name: Create SRPM
        env:
          VERSION: ${{ steps.version.outputs.version }}
          WORKSPACE: ${{ github.workspace }}
        run: |
          echo "Creating SRPM for version $VERSION"

          # Copy and update spec file
          cp $WORKSPACE/installer/centos/sysmanage.spec ~/rpmbuild/SOURCES/
          cd ~/rpmbuild/SOURCES

          # Update version in spec file
          sed -i "s/^Version:.*/Version:        $VERSION/" sysmanage.spec

          # Build SRPM
          rpmbuild -bs sysmanage.spec --define "_topdir $HOME/rpmbuild"

          # Find the SRPM
          SRPM=$(find ~/rpmbuild/SRPMS -name "sysmanage-*.src.rpm" | head -1)
          echo "Created SRPM: $SRPM"
          ls -lh $SRPM

          # Save SRPM path for next step
          echo "SRPM_PATH=$SRPM" >> $GITHUB_ENV

      - name: Upload to Copr
        env:
          VERSION: ${{ steps.version.outputs.version }}
          COPR_USERNAME: ${{ secrets.COPR_USERNAME }}
        run: |
          echo "Uploading SRPM to Copr..."
          echo "Project: $COPR_USERNAME/sysmanage"
          echo "SRPM: $SRPM_PATH"

          # Upload and build
          copr-cli build $COPR_USERNAME/sysmanage $SRPM_PATH

          echo ""
          echo "=========================================="
          echo "SUCCESS! Uploaded version $VERSION to Copr"
          echo "=========================================="
          echo ""
          echo "View build status at:"
          echo "https://copr.fedorainfracloud.org/coprs/$COPR_USERNAME/sysmanage/builds/"
          echo ""
          echo "Copr will now build for all configured chroots:"
          echo "  - Fedora 41 (Python 3.13)"
          echo "  - Fedora 42 (Python 3.13)"
          echo "  - EPEL 10 (RHEL 10, CentOS Stream 10 - Python 3.12)"
          echo ""
          echo "Installation instructions:"
          echo "  sudo dnf copr enable $COPR_USERNAME/sysmanage"
          echo "  sudo dnf install sysmanage"
          echo "=========================================="

  deploy-snap:
    name: Deploy to Snap Store
    runs-on: ubuntu-24.04
    needs: [release]
    if: startsWith(github.ref, 'refs/tags/')

    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Set up Python 3.12
        uses: actions/setup-python@v6
        with:
          python-version: '3.12'

      - name: Determine version
        id: version
        run: |
          VERSION="${GITHUB_REF#refs/tags/v}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Building and deploying Snap for version: $VERSION"

      - name: Generate requirements-prod.txt
        run: |
          python3 scripts/update-requirements-prod.py

      - name: Copy snapcraft.yaml and icon to root
        run: |
          cp installer/snap/snapcraft.yaml .
          # Replace version: git with the actual tag version
          sed -i "s/^version: git$/version: ${{ steps.version.outputs.version }}/" snapcraft.yaml
          mkdir -p snap/gui
          cp installer/snap/gui/icon.svg snap/gui/icon.svg

      - name: Build and publish snap
        uses: snapcore/action-build@v1
        with:
          snapcraft-channel: latest/edge

      - name: Get snap filename
        id: snap_file
        run: |
          SNAP_FILE=$(ls *.snap | head -1)
          echo "snap_file=$SNAP_FILE" >> $GITHUB_OUTPUT
          echo "Built snap: $SNAP_FILE"

      - name: Publish to Snap Store
        uses: snapcore/action-publish@v1
        env:
          SNAPCRAFT_STORE_CREDENTIALS: ${{ secrets.SNAP_STORE_TOKEN }}
        with:
          snap: ${{ steps.snap_file.outputs.snap_file }}
          release: stable

      - name: Deployment summary
        run: |
          echo "=========================================="
          echo "SUCCESS! Published to Snap Store"
          echo "=========================================="
          echo ""
          echo "The snap is now available at:"
          echo "https://snapcraft.io/sysmanage"
          echo ""
          echo "Users can install with:"
          echo "  sudo snap install sysmanage"
          echo "=========================================="
