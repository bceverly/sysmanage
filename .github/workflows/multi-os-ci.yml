name: Multi-OS CI/CD Pipeline with Performance Testing

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

permissions:
  contents: read

jobs:
  # Linux backend testing with PostgreSQL
  test-backend-postgres:
    name: Backend Tests (Linux + PostgreSQL)
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write

    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: abc123
          POSTGRES_USER: sysmanage
          POSTGRES_DB: sysmanage
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
    - uses: actions/checkout@v5

    - name: Set up Python 3.12
      uses: actions/setup-python@v5
      with:
        python-version: '3.12'

    - name: Cache pip packages
      uses: actions/cache@v4
      with:
        path: ~/.cache/pip
        key: ubuntu-latest-pip-${{ hashFiles('**/requirements.txt') }}
        restore-keys: |
          ubuntu-latest-pip-

    - name: Install Python dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pytest pytest-cov pytest-asyncio

    - name: Create test config (Linux + PostgreSQL)
      run: |
        sudo mkdir -p /etc
        sudo tee /etc/sysmanage.yaml > /dev/null <<EOF
        api:
          host: "localhost"
          port: 8000
          certFile: ""
          chainFile: ""
          keyFile: ""
        database:
          user: "sysmanage"
          password: "abc123"
          host: "localhost"
          port: 5432
          name: "sysmanage"
        security:
          password_salt: "TEST_fBLqXrh6evnpiDOEA+TtFy1c4ItzVIyyMUsYhCraqLs="
          admin_userid: "admin@sysmanage.org"
          admin_password: "TEST_AdminPass123!"
          jwt_secret: "TEST_SuCHjkous8e0OgHRPxZ1Uayz0NS0b0SGXUXS26MUaZU="
          jwt_algorithm: "HS256"
          jwt_auth_timeout: 6000
          jwt_refresh_timeout: 60000
        webui:
          host: "localhost"
          port: 7443
        EOF

    - name: Run backend database migrations
      run: |
        python -m alembic upgrade head
      env:
        PYTHONPATH: .
        DATABASE_URL: postgresql://sysmanage:abc123@localhost:5432/sysmanage

    - name: Run backend tests with PostgreSQL
      run: |
        python -m pytest tests/ --ignore=tests/ui/ -v --tb=short --cov=backend --cov-report=term-missing --cov-report=html --cov-report=xml
      env:
        PYTHONPATH: .
        DATABASE_URL: postgresql://sysmanage:abc123@localhost:5432/sysmanage

    - name: Upload coverage reports
      uses: codecov/codecov-action@v5
      with:
        files: ./coverage.xml
        flags: backend-linux-postgres
        name: backend-coverage-linux-postgres

  # Multi-OS backend testing with SQLite
  test-backend:
    name: Backend Tests (${{ matrix.os }})
    runs-on: ${{ matrix.os }}
    permissions:
      contents: write
      pull-requests: write

    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        python-version: ['3.12']

    steps:
    - uses: actions/checkout@v5

    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v5
      with:
        python-version: ${{ matrix.python-version }}

    - name: Cache pip packages
      uses: actions/cache@v4
      with:
        path: |
          ~/.cache/pip
          ~/AppData/Local/pip/Cache
          ~/Library/Caches/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-

    - name: Install Python dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pytest pytest-cov pytest-asyncio

    - name: Create test config (macOS with SQLite)
      if: runner.os == 'macOS'
      run: |
        sudo mkdir -p /etc
        sudo tee /etc/sysmanage.yaml > /dev/null <<EOF
        api:
          host: "localhost"
          port: 8000
          certFile: ""
          chainFile: ""
          keyFile: ""
        database:
          user: "sqlite"
          password: ""
          host: ""
          port: 0
          name: "test_macos.db"
        security:
          password_salt: "TEST_fBLqXrh6evnpiDOEA+TtFy1c4ItzVIyyMUsYhCraqLs="
          admin_userid: "admin@sysmanage.org"
          admin_password: "TEST_AdminPass123!"
          jwt_secret: "TEST_SuCHjkous8e0OgHRPxZ1Uayz0NS0b0SGXUXS26MUaZU="
          jwt_algorithm: "HS256"
          jwt_auth_timeout: 6000
          jwt_refresh_timeout: 60000
        webui:
          host: "localhost"
          port: 7443
        EOF

    - name: Create test config (Windows with SQLite)
      if: runner.os == 'Windows'
      run: |
        New-Item -ItemType Directory -Force -Path "C:\ProgramData\sysmanage"
        @"
        api:
          host: "localhost"
          port: 8000
          certFile: ""
          chainFile: ""
          keyFile: ""
        database:
          user: "sqlite"
          password: ""
          host: ""
          port: 0
          name: "test_windows.db"
        security:
          password_salt: "TEST_fBLqXrh6evnpiDOEA+TtFy1c4ItzVIyyMUsYhCraqLs="
          admin_userid: "admin@sysmanage.org"
          admin_password: "TEST_AdminPass123!"
          jwt_secret: "TEST_SuCHjkous8e0OgHRPxZ1Uayz0NS0b0SGXUXS26MUaZU="
          jwt_algorithm: "HS256"
          jwt_auth_timeout: 6000
          jwt_refresh_timeout: 60000
        webui:
          host: "localhost"
          port: 7443
        "@ | Out-File -FilePath "C:\ProgramData\sysmanage\sysmanage.yaml" -Encoding UTF8
      shell: powershell

    - name: Create test config (Linux with SQLite)
      if: runner.os == 'Linux'
      run: |
        sudo mkdir -p /etc
        sudo tee /etc/sysmanage.yaml > /dev/null <<EOF
        api:
          host: "localhost"
          port: 8000
          certFile: ""
          chainFile: ""
          keyFile: ""
        database:
          user: "sqlite"
          password: ""
          host: ""
          port: 0
          name: "test_linux.db"
        security:
          password_salt: "TEST_fBLqXrh6evnpiDOEA+TtFy1c4ItzVIyyMUsYhCraqLs="
          admin_userid: "admin@sysmanage.org"
          admin_password: "TEST_AdminPass123!"
          jwt_secret: "TEST_SuCHjkous8e0OgHRPxZ1Uayz0NS0b0SGXUXS26MUaZU="
          jwt_algorithm: "HS256"
          jwt_auth_timeout: 6000
          jwt_refresh_timeout: 60000
        webui:
          host: "localhost"
          port: 7443
        EOF

    - name: Run backend database migrations
      run: |
        python -m alembic upgrade head
      env:
        PYTHONPATH: .
        DATABASE_URL: sqlite:///test_${{ runner.os }}.db

    - name: Run backend tests
      run: |
        python -m pytest tests/ --ignore=tests/ui/ -v --tb=short --cov=backend --cov-report=term-missing --cov-report=html --cov-report=xml
      env:
        PYTHONPATH: .
        DATABASE_URL: sqlite:///test_${{ runner.os }}.db

    - name: Upload coverage reports
      uses: codecov/codecov-action@v5
      with:
        files: ./coverage.xml
        flags: backend-${{ matrix.os }}
        name: backend-coverage-${{ matrix.os }}

  # Multi-OS frontend testing
  test-frontend:
    name: Frontend Tests (${{ matrix.os }})
    runs-on: ${{ matrix.os }}

    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        node-version: ['20']

    steps:
    - uses: actions/checkout@v5

    - name: Set up Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v4
      with:
        node-version: ${{ matrix.node-version }}
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json

    - name: Install frontend dependencies
      run: npm ci
      working-directory: frontend

    - name: Run frontend tests
      run: npm run test:coverage
      working-directory: frontend

    - name: Build frontend
      run: npm run build
      working-directory: frontend

    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: frontend-build-${{ matrix.os }}
        path: frontend/build/

  # Multi-OS UI and Performance testing
  test-ui-performance:
    name: UI & Performance Tests (${{ matrix.os }})
    runs-on: ${{ matrix.os }}
    needs: [test-frontend]

    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        python-version: ['3.12']
        node-version: ['20']

    steps:
    - uses: actions/checkout@v5

    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v5
      with:
        python-version: ${{ matrix.python-version }}

    - name: Set up Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v4
      with:
        node-version: ${{ matrix.node-version }}
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json

    - name: Install Artillery globally
      run: npm install -g artillery@latest

    - name: Install Python dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pytest pytest-asyncio

    - name: Install Playwright browsers
      run: |
        pip install playwright
        playwright install chromium firefox
        # Install WebKit only on macOS
        if [ "${{ runner.os }}" == "macOS" ]; then
          playwright install webkit
        fi
      shell: bash

    - name: Install additional system dependencies (Linux)
      if: runner.os == 'Linux'
      run: |
        sudo apt-get update
        sudo apt-get install -y \
          libnss3 libnspr4 libdbus-1-3 libatk1.0-0 libatk-bridge2.0-0 \
          libdrm2 libxkbcommon0 libgtk-3-0 libgdk-pixbuf2.0-0

    - name: Download frontend build
      uses: actions/download-artifact@v5
      with:
        name: frontend-build-${{ matrix.os }}
        path: frontend/build/

    - name: Create test config
      run: |
        echo "Creating test config for ${{ runner.os }}..."

        # Create config content first
        cat > temp_config.yaml <<EOF
        api:
          host: "localhost"
          port: 8001
          certFile: ""
          chainFile: ""
          keyFile: ""
        database:
          user: "sqlite"
          password: ""
          host: ""
          port: 0
          name: "test.db"
        security:
          password_salt: "TEST_fBLqXrh6evnpiDOEA+TtFy1c4ItzVIyyMUsYhCraqLs="
          admin_userid: "admin@sysmanage.org"
          admin_password: "TEST_AdminPass123!"
          jwt_secret: "TEST_SuCHjkous8e0OgHRPxZ1Uayz0NS0b0SGXUXS26MUaZU="
          jwt_algorithm: "HS256"
          jwt_auth_timeout: 6000
          jwt_refresh_timeout: 60000
        webui:
          host: "localhost"
          port: 7443
        EOF

        # Platform-specific config placement
        if [ "${{ runner.os }}" == "Windows" ]; then
          echo "Setting up config for Windows..."
          mkdir -p "/c/ProgramData/sysmanage"
          cp temp_config.yaml "/c/ProgramData/sysmanage/sysmanage.yaml"
        else
          echo "Setting up config for Unix-like system (${{ runner.os }})..."
          sudo mkdir -p /etc
          sudo cp temp_config.yaml /etc/sysmanage.yaml
        fi

        # Cleanup
        rm temp_config.yaml

        echo "Config created successfully for ${{ runner.os }}"
      shell: bash

    - name: Run database migrations for UI tests
      run: |
        echo "ðŸ—„ï¸ Running database migrations..."
        python -m alembic upgrade head
      env:
        PYTHONPATH: .
        DATABASE_URL: sqlite:///test.db

    - name: Create test user for UI tests
      run: |
        echo "ðŸ‘¤ Creating test user..."
        python -c "
        from backend.persistence import db
        from backend.persistence.models import User
        from sqlalchemy.orm import sessionmaker
        from argon2 import PasswordHasher
        import os

        os.environ['DATABASE_URL'] = 'sqlite:///test.db'

        engine = db.get_engine()
        SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
        hasher = PasswordHasher()

        with SessionLocal() as session:
            # Check if admin user already exists
            existing_user = session.query(User).filter(User.userid == 'admin@test.com').first()
            if not existing_user:
                # Create admin user with password 'admin'
                # userid must be email format for Pydantic EmailStr validation
                admin_user = User(
                    userid='admin@test.com',
                    hashed_password=hasher.hash('admin'),
                    active=True,
                    is_admin=True
                )
                session.add(admin_user)
                session.commit()
                print('Test admin user created')
            else:
                print('Admin user already exists')
        "
      env:
        PYTHONPATH: .
        DATABASE_URL: sqlite:///test.db

    - name: Start SysManage server for UI tests
      run: |
        echo "ðŸš€ Starting SysManage backend and frontend servers..."

        # Start backend API server (with CI environment flag for faster startup)
        echo "Starting backend on port 8001..."
        SYSMANAGE_CI_MODE=true python -m uvicorn backend.main:app --host 0.0.0.0 --port 8001 &
        BACKEND_PID=$!
        echo "BACKEND_PID=$BACKEND_PID" >> $GITHUB_ENV

        # Wait for backend to start (extended timeout for CI environments)
        echo "Waiting for backend API to start..."
        for i in {1..120}; do
          if curl -f http://localhost:8001/api/health > /dev/null 2>&1; then
            echo "âœ… Backend API health check passed on port 8001"
            # Also test the login endpoint specifically
            if curl -f -X POST http://localhost:8001/login -H "Content-Type: application/json" -d '{"userid":"admin@test.com","password":"admin"}' > /dev/null 2>&1; then
              echo "âœ… Backend login endpoint is accessible"
              break
            else
              echo "âš ï¸ Health check passed but login endpoint not ready yet..."
            fi
          fi
          if [ $i -eq 120 ]; then
            echo "âŒ Backend failed to start after 120 seconds"
            echo "Checking backend process status..."
            if ps -p $BACKEND_PID > /dev/null 2>&1; then
              echo "Backend process is still running (PID: $BACKEND_PID)"
              echo "Checking what's listening on port 8001..."
              netstat -tlnp 2>/dev/null | grep :8001 || echo "No process listening on port 8001"
              echo "Trying to connect directly..."
              curl -v http://localhost:8001/api/health || echo "Direct connection failed"
              exit 1
            else
              echo "Backend process has died (PID: $BACKEND_PID)"
              exit 1
            fi
          fi
          if [ $((i % 15)) -eq 0 ]; then
            echo "Still waiting for backend... (attempt $i/120)"
          fi
          sleep 1
        done

        # Install frontend dependencies if needed
        if [ ! -d "frontend/node_modules" ]; then
          echo "Installing frontend dependencies..."
          cd frontend && npm install && cd ..
        fi

        # Start frontend web UI server
        echo "Starting frontend on port 7443..."
        cd frontend
        FORCE_HTTP=true VITE_HOST=localhost VITE_PORT=7443 VITE_BACKEND_PORT=8001 npm start -- --host localhost --port 7443 &
        FRONTEND_PID=$!
        echo "FRONTEND_PID=$FRONTEND_PID" >> $GITHUB_ENV
        cd ..

        # Wait for frontend to start
        echo "Waiting for frontend web UI to start..."
        for i in {1..60}; do
          if curl -f http://localhost:7443 > /dev/null 2>&1; then
            echo "âœ… Frontend UI is running on port 7443"
            break
          fi
          if [ $i -eq 60 ]; then
            echo "âŒ Frontend failed to start after 60 seconds"
            exit 1
          fi
          echo "Waiting for frontend... (attempt $i/60)"
          sleep 2
        done

        echo "âœ… Both backend (8001) and frontend (7443) are running"
        echo "ðŸ” Final connectivity check..."
        curl -f http://localhost:8001/api/health && echo "Backend health OK"
        curl -f http://localhost:7443 && echo "Frontend OK"
      shell: bash
      env:
        PYTHONPATH: .
        DATABASE_URL: sqlite:///test.db

    - name: Run UI tests with performance metrics
      run: |
        echo "ðŸŽ­ Running UI tests with performance metrics collection..."
        if [ "${{ runner.os }}" == "Darwin" ]; then
          echo "ðŸŽ macOS detected - testing Chrome, Firefox, and WebKit/Safari"
        else
          echo "ðŸ§ ${{ runner.os }} detected - testing Chrome and Firefox"
        fi

        PYTHONPATH=tests/ui:$PYTHONPATH python -m pytest tests/ui/test_login_cross_browser.py --confcutdir=tests/ui -p tests.ui.conftest_playwright -v --tb=short
      shell: bash
      env:
        PYTHONPATH: .

    - name: Run dedicated performance tests (Skip Artillery on Windows due to complexity)
      if: runner.os != 'Windows'
      run: |
        echo "ðŸš€ Running performance tests..."
        PYTHONPATH=tests/ui:$PYTHONPATH python -m pytest tests/ui/test_performance_playwright.py --confcutdir=tests/ui -p tests.ui.conftest_playwright -v --tb=short
      shell: bash
      env:
        PYTHONPATH: .

    - name: Stop SysManage servers after UI tests
      if: always()
      run: |
        echo "ðŸ›‘ Stopping SysManage servers..."

        # Stop backend server
        if [ -n "$BACKEND_PID" ]; then
          kill $BACKEND_PID || true
          echo "Backend stopped (PID: $BACKEND_PID)"
        else
          echo "No backend PID found, attempting to kill by port..."
          pkill -f "uvicorn.*--port 8001" || true
        fi

        # Stop frontend server
        if [ -n "$FRONTEND_PID" ]; then
          kill $FRONTEND_PID || true
          echo "Frontend stopped (PID: $FRONTEND_PID)"
        else
          echo "No frontend PID found, attempting to kill by port..."
          pkill -f "npm.*start.*--port 7443" || true
          pkill -f "vite.*--port 7443" || true
        fi

        echo "âœ… Server cleanup completed"
      shell: bash

    - name: Run Artillery load tests (Linux/macOS only)
      if: runner.os != 'Windows'
      run: |
        echo "âš¡ Running Artillery load tests..."
        # Start server in background
        python -m uvicorn backend.main:app --host localhost --port 8001 &
        SERVER_PID=$!
        sleep 10

        # Run Artillery tests
        artillery run artillery.yml --output artillery-report-${{ runner.os }}.json || echo "Artillery tests completed with warnings"

        # Generate report
        if [ -f artillery-report-${{ runner.os }}.json ]; then
          artillery report artillery-report-${{ runner.os }}.json --output artillery-report-${{ runner.os }}.html
          echo "ðŸ“Š Artillery report generated: artillery-report-${{ runner.os }}.html"
        fi

        # Stop server
        kill $SERVER_PID 2>/dev/null || true
      shell: bash
      env:
        PYTHONPATH: .

    - name: Upload performance results
      uses: actions/upload-artifact@v4
      with:
        name: performance-results-${{ matrix.os }}
        path: |
          performance-results.json
          artillery-report-*.json
          artillery-report-*.html

    - name: Upload UI test artifacts
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: ui-test-artifacts-${{ matrix.os }}-${{ github.run_number }}
        path: |
          tests/ui/test-results/
          tests/ui/playwright-report/
        if-no-files-found: warn

  # Performance regression analysis
  analyze-performance:
    name: Performance Regression Analysis
    runs-on: ubuntu-latest
    needs: [test-ui-performance]
    if: always()

    steps:
    - uses: actions/checkout@v5

    - name: Download all performance results
      uses: actions/download-artifact@v5
      with:
        pattern: performance-results-*
        merge-multiple: true

    - name: Analyze performance trends
      run: |
        echo "ðŸ“Š Analyzing performance trends across platforms..."

        # Create performance summary
        echo "# Performance Test Summary" > performance-summary.md
        echo "## Test Run: ${{ github.run_number }}" >> performance-summary.md
        echo "## Commit: ${{ github.sha }}" >> performance-summary.md
        echo "" >> performance-summary.md

        # Process Playwright performance results
        for file in performance-results.json*; do
          if [ -f "$file" ]; then
            echo "### Playwright Performance Metrics" >> performance-summary.md
            echo "\`\`\`json" >> performance-summary.md
            cat "$file" >> performance-summary.md
            echo "\`\`\`" >> performance-summary.md
            echo "" >> performance-summary.md
          fi
        done

        # Process Artillery results
        for file in artillery-report-*.json; do
          if [ -f "$file" ]; then
            OS=$(echo "$file" | sed 's/artillery-report-\(.*\)\.json/\1/')
            echo "### Artillery Load Test Results ($OS)" >> performance-summary.md
            echo "Artillery report available: artillery-report-$OS.html" >> performance-summary.md
            echo "" >> performance-summary.md
          fi
        done

        echo "ðŸ“„ Performance summary created"
        cat performance-summary.md
      shell: bash

    - name: Upload performance summary
      uses: actions/upload-artifact@v4
      with:
        name: performance-summary
        path: |
          performance-summary.md
          artillery-report-*.html

  # Final status aggregation
  ci-status:
    name: CI Status Summary
    runs-on: ubuntu-latest
    needs: [test-backend, test-frontend, test-ui-performance, analyze-performance]
    if: always()

    steps:
    - name: Check all job statuses
      run: |
        echo "ðŸ” CI/CD Pipeline Status Summary"
        echo "Backend Tests: ${{ needs.test-backend.result }}"
        echo "Frontend Tests: ${{ needs.test-frontend.result }}"
        echo "UI & Performance Tests: ${{ needs.test-ui-performance.result }}"
        echo "Performance Analysis: ${{ needs.analyze-performance.result }}"

        # Determine overall status
        if [[ "${{ needs.test-backend.result }}" == "success" &&
              "${{ needs.test-frontend.result }}" == "success" &&
              "${{ needs.test-ui-performance.result }}" == "success" ]]; then
          echo "âœ… All critical tests passed!"
          echo "overall_status=success" >> $GITHUB_ENV
        else
          echo "âŒ Some tests failed"
          echo "overall_status=failure" >> $GITHUB_ENV
          exit 1
        fi
      shell: bash